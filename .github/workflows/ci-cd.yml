name: CI/CD Pipeline

on:
  # push:
  #   branches: [ main ]
  # pull_request:
  #   branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      skip_tests:
        description: 'Skip validation tests'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  pull-requests: write
  checks: write

env:
  DOTNET_VERSION: '10.x'
  BUILD_CONFIGURATION: 'Release'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 'true'
  DOTNET_NOLOGO: 'true'

jobs:
  build-dacpac:
    name: Build Database DACPAC
    runs-on: [self-hosted, windows, sql-server]
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Initialize CLR Signing Certificate
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Initializing CLR signing certificate (idempotent)..."
          
          # Call script and capture result
          $result = & ./scripts/Initialize-CLRSigning.ps1
          $exitCode = $LASTEXITCODE
          
          # If LASTEXITCODE is null/empty, the script succeeded (returned an object)
          if ($null -eq $exitCode -or $exitCode -eq 0) {
            Write-Host "‚úì CLR signing certificate initialized"
            exit 0
          } else {
            throw "Certificate initialization failed with exit code $exitCode"
          }
      
      - name: Build DACPAC with MSBuild
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Building SQL Database Project..."
          
          $projectPath = Join-Path $env:GITHUB_WORKSPACE "src\Hartonomous.Database\Hartonomous.Database.sqlproj"
          
          # Try multiple MSBuild discovery methods
          $msbuildPath = $null
          
          # Method 1: vswhere (most reliable for installed VS)
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (Test-Path $vswhere) {
            $msbuildPath = & $vswhere -latest -requires Microsoft.Component.MSBuild -find MSBuild\**\Bin\MSBuild.exe | Select-Object -First 1
          }
          
          # Method 2: Direct VS 2022 paths
          if (-not $msbuildPath) {
            $vsPaths = @(
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\MSBuild.exe"
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Professional\MSBuild\Current\Bin\MSBuild.exe"
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe"
              "${env:ProgramFiles}\Microsoft Visual Studio\18\Insiders\MSBuild\Current\Bin\MSBuild.exe"
            )
            foreach ($path in $vsPaths) {
              if (Test-Path $path) {
                $msbuildPath = $path
                break
              }
            }
          }
          
          # Method 3: Build Tools standalone installation
          if (-not $msbuildPath) {
            $buildToolsPath = "${env:ProgramFiles}\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\MSBuild.exe"
            if (Test-Path $buildToolsPath) {
              $msbuildPath = $buildToolsPath
            }
          }
          
          if (-not $msbuildPath) {
            throw "MSBuild not found. Install Visual Studio 2022 or VS Build Tools with MSBuild component."
          }
          
          Write-Host "Using MSBuild: $msbuildPath"
          
          & $msbuildPath $projectPath `
            /p:Configuration=Release `
            /t:Build `
            /v:minimal
          
          if ($LASTEXITCODE -ne 0) {
            throw "DACPAC build failed with exit code $LASTEXITCODE"
          }
          
          # Find the built DACPAC
          $dacpacPath = Get-ChildItem -Path (Join-Path $env:GITHUB_WORKSPACE "src\Hartonomous.Database") -Recurse -Filter "Hartonomous.Database.dacpac" | Select-Object -First 1
          
          if (-not $dacpacPath) {
            throw "DACPAC file not found after build"
          }
          
          Write-Host "‚úì DACPAC built: $($dacpacPath.FullName)"
          
          # Copy to artifacts directory for upload
          $artifactDir = Join-Path $env:GITHUB_WORKSPACE "artifacts\database"
          New-Item -ItemType Directory -Path $artifactDir -Force | Out-Null
          Copy-Item -Path $dacpacPath.FullName -Destination $artifactDir -Force
          
          Write-Host "‚úì DACPAC copied to artifacts"
      
      - name: Sign CLR Assemblies
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Signing CLR assemblies..."
          
          # The DACPAC build outputs to src\Hartonomous.Database\bin\Release\
          # Sign-CLRAssemblies.ps1 expects to find DLLs there
          $buildOutput = "src\Hartonomous.Database\bin\Release"
          
          if (-not (Test-Path $buildOutput)) {
            throw "Build output not found at: $buildOutput. DACPAC build may have failed."
          }
          
          # List DLLs found
          $dlls = Get-ChildItem -Path $buildOutput -Filter "*.dll" -Recurse
          Write-Host "Found $($dlls.Count) DLL files to sign"
          
          # Call signing script
          & ./scripts/Sign-CLRAssemblies.ps1 -Configuration Release -Verbose
          
          Write-Host "‚úì CLR assemblies signed"
      
      - name: Upload DACPAC artifact
        uses: actions/upload-artifact@v4
        with:
          name: database-dacpac
          path: artifacts/database/
          retention-days: 7
      
      - name: Upload CLR dependencies
        uses: actions/upload-artifact@v4
        with:
          name: clr-dependencies
          path: dependencies/
          retention-days: 7
      
      - name: Upload deployment scripts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-scripts
          path: scripts/
          retention-days: 7

  deploy-database:
    needs: build-dacpac
    runs-on: [self-hosted, windows, sql-server]
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Download DACPAC Artifact
        uses: actions/download-artifact@v4
        with:
          name: database-dacpac
          path: ./artifacts/database

      - name: Download CLR Dependencies
        uses: actions/download-artifact@v4
        with:
          name: clr-dependencies
          path: ./dependencies

      - name: Download Deployment Scripts
        uses: actions/download-artifact@v4
        with:
          name: deployment-scripts
          path: ./scripts

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy CLR Signing Certificate to SQL Server
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Deploying CLR signing certificate to SQL Server (production mode)..."
          
          # Call script - will throw on error
          & ./scripts/Deploy-CLRCertificate.ps1 `
            -Server "${{ secrets.SQL_SERVER }}" `
            -Database "${{ secrets.SQL_DATABASE }}" `
            -EnableStrictSecurity $true
          
          Write-Host "‚úì CLR signing certificate deployed with CLR Strict Security enabled"

      - name: Install SqlPackage
        run: |
          $ErrorActionPreference = 'Stop'
          
          # Check if SqlPackage is already available
          $existing = Get-Command sqlpackage -ErrorAction SilentlyContinue
          if ($existing) {
            Write-Host "‚úì SqlPackage already installed at: $($existing.Source)"
            & sqlpackage /version
            exit 0
          }
          
          Write-Host "Installing SqlPackage via dotnet tool..."
          dotnet tool install -g microsoft.sqlpackage
          
          # Add dotnet tools directory to PATH for this workflow run
          $toolsPath = Join-Path $env:USERPROFILE ".dotnet\tools"
          if (-not (Test-Path $toolsPath)) {
            # Network Service account uses different profile path
            $toolsPath = "C:\WINDOWS\ServiceProfiles\NetworkService\.dotnet\tools"
          }
          
          if (Test-Path $toolsPath) {
            Write-Host "Adding $toolsPath to PATH"
            echo "$toolsPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          }
          
          # Verify installation by checking the expected install location directly
          $sqlPackageExe = Join-Path $toolsPath "sqlpackage.exe"
          if (Test-Path $sqlPackageExe) {
            Write-Host "‚úì SqlPackage installed successfully at: $sqlPackageExe"
            & $sqlPackageExe /version
          } else {
            throw "SqlPackage installation failed - sqlpackage.exe not found at $sqlPackageExe"
          }
        shell: pwsh

      - name: Get Azure AD Access Token for SQL
        id: get_token
        run: |
          $token = (az account get-access-token --resource https://database.windows.net --query accessToken -o tsv)
          if (-not $token) {
            throw "Failed to retrieve Azure AD token for SQL Server."
          }
          echo "::add-mask::$token"
          echo "token=$token" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: pwsh

      - name: Execute Unified Database Deployment
        run: |
          $ErrorActionPreference = 'Stop'
          
          # Dynamically locate the DACPAC
          $dacpacPath = Get-ChildItem -Path "./artifacts/database" -Filter "*.dacpac" -File | Select-Object -First 1
          
          if (-not $dacpacPath) {
            throw "DACPAC file not found in artifacts/database"
          }
          
          Write-Host "Deploying DACPAC: $($dacpacPath.FullName)"
          
          ./scripts/Deploy-Database.ps1 `
            -Server "${{ secrets.SQL_SERVER }}" `
            -Database "${{ secrets.SQL_DATABASE }}" `
            -AccessToken "${{ steps.get_token.outputs.token }}" `
            -DacpacPath "$($dacpacPath.FullName)" `
            -DependenciesPath "./dependencies" `
            -ScriptsPath "./scripts/sql"
        shell: pwsh

      - name: Verify CLR Assembly Signatures and Security
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Verifying CLR assembly signatures and security configuration..."
          
          # Query to verify signatures and CLR Strict Security
          $query = @"
          -- Check CLR Strict Security (should be 1 in production)
          SELECT name, CAST(value AS int) AS value, CAST(value_in_use AS int) AS value_in_use
          FROM sys.configurations 
          WHERE name = 'clr strict security';
          
          -- Check all assemblies and their signatures
          SELECT 
            a.name AS AssemblyName,
            CASE a.permission_set 
              WHEN 1 THEN 'SAFE'
              WHEN 2 THEN 'EXTERNAL_ACCESS'
              WHEN 3 THEN 'UNSAFE_ACCESS'
            END AS PermissionSet,
            CASE 
              WHEN c.name IS NOT NULL THEN 'SIGNED (via Certificate)'
              WHEN ak.name IS NOT NULL THEN 'SIGNED (via Asymmetric Key)'
              ELSE 'UNSIGNED'
            END AS SignatureStatus,
            c.name AS CertificateName
          FROM sys.assemblies a
          LEFT JOIN sys.assembly_files af ON a.assembly_id = af.assembly_id
          LEFT JOIN sys.certificates c ON c.thumbprint = af.content
          LEFT JOIN sys.asymmetric_keys ak ON ak.thumbprint = af.content
          WHERE a.name NOT IN ('master', 'model', 'msdb', 'tempdb')
          ORDER BY a.name;
          "@
          
          # Use Azure AD authentication for verification
          $token = "${{ steps.get_token.outputs.token }}"
          
          # Install SqlServer module if not present
          if (-not (Get-Module -ListAvailable -Name SqlServer)) {
            Install-Module -Name SqlServer -Force -AllowClobber -Scope CurrentUser
          }
          
          Import-Module SqlServer
          
          $result = Invoke-Sqlcmd `
            -ServerInstance "${{ secrets.SQL_SERVER }}" `
            -Database "${{ secrets.SQL_DATABASE }}" `
            -AccessToken $token `
            -Query $query `
            -QueryTimeout 30
          
          Write-Host "`n=== CLR Security Verification Results ==="
          $result | Format-Table -AutoSize
          
          # Check for unsigned assemblies (fail if any found in production)
          $unsigned = $result | Where-Object { $_.SignatureStatus -eq 'UNSIGNED' }
          if ($unsigned) {
            Write-Host "`n‚ùå ERROR: Unsigned assemblies detected in production mode!"
            Write-Host "All assemblies must be signed for ISO-certification compliance."
            $unsigned | Format-Table -AutoSize
            exit 1
          }
          
          # Check CLR Strict Security is enabled
          $strictSecurity = $result | Where-Object { $_.name -eq 'clr strict security' }
          if ($strictSecurity -and $strictSecurity.value_in_use -eq 0) {
            Write-Host "`n‚ùå ERROR: CLR Strict Security is DISABLED in production!"
            exit 1
          }
          
          Write-Host "`n‚úì CLR security verification complete - all assemblies signed, CLR Strict Security enabled"

  scaffold-entities:
    name: Scaffold EF Core Entities
    runs-on: [self-hosted, windows, sql-server]
    needs: deploy-database
    environment: production
    permissions:
      contents: write
      id-token: write
    
    env:
      SQL_SERVER: ${{ secrets.SQL_SERVER }}
      SQL_DATABASE: ${{ secrets.SQL_DATABASE }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Verify .NET SDK
        run: |
          $ErrorActionPreference = 'Stop'
          
          # Check if dotnet is available
          $dotnetCmd = Get-Command dotnet -ErrorAction SilentlyContinue
          if (-not $dotnetCmd) {
            throw ".NET SDK not found. Install .NET ${{ env.DOTNET_VERSION }} or later on the self-hosted runner."
          }
          
          Write-Host "‚úì .NET SDK found at: $($dotnetCmd.Source)"
          
          # Verify version
          $version = & dotnet --version
          Write-Host "‚úì .NET SDK version: $version"
          
          # Check if version meets minimum requirement (10.0)
          $minVersion = [version]"10.0"
          $installedVersion = [version]$version
          
          if ($installedVersion -lt $minVersion) {
            Write-Host "‚ö†Ô∏è Warning: Installed .NET version $version is older than required ${{ env.DOTNET_VERSION }}"
            Write-Host "Proceeding anyway - may cause compatibility issues"
          } else {
            Write-Host "‚úì .NET SDK version meets minimum requirement (${{ env.DOTNET_VERSION }})"
          }
        shell: pwsh
      
      - name: Install EF Core tools
        run: |
          $ErrorActionPreference = 'Stop'
          
          # Check if dotnet-ef is already installed
          $existingEf = Get-Command dotnet-ef -ErrorAction SilentlyContinue
          if ($existingEf) {
            Write-Host "‚úì dotnet-ef already installed at: $($existingEf.Source)"
            & dotnet-ef --version
            exit 0
          }
          
          Write-Host "Installing dotnet-ef version 10.0.0..."
          dotnet tool install --global dotnet-ef --version 10.0.0
          
          # Add dotnet tools directory to PATH for this workflow run
          $toolsPath = Join-Path $env:USERPROFILE ".dotnet\tools"
          if (-not (Test-Path $toolsPath)) {
            # Network Service account uses different profile path
            $toolsPath = "C:\WINDOWS\ServiceProfiles\NetworkService\.dotnet\tools"
          }
          
          if (Test-Path $toolsPath) {
            Write-Host "Adding $toolsPath to PATH"
            echo "$toolsPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          }
          
          # Verify installation
          $efExe = Join-Path $toolsPath "dotnet-ef.exe"
          if (Test-Path $efExe) {
            Write-Host "‚úì dotnet-ef installed successfully at: $efExe"
            & $efExe --version
          } else {
            throw "dotnet-ef installation failed - executable not found at $efExe"
          }
        shell: pwsh
      
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get SQL Access Token
        id: get-token
        shell: pwsh
        run: |
          $token = (az account get-access-token --resource https://database.windows.net --query accessToken -o tsv)
          echo "::add-mask::$token"
          "token=$token" >> $env:GITHUB_OUTPUT
      
      - name: Scaffold EF Core Entities
        shell: pwsh
        env:
          AZURE_SQL_ACCESS_TOKEN: ${{ steps.get-token.outputs.token }}
          SQL_SERVER: ${{ env.SQL_SERVER }}
          SQL_DATABASE: ${{ env.SQL_DATABASE }}
        run: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Scaffolding EF Core entities from database schema..."
          Write-Host "Access token length: $($env:AZURE_SQL_ACCESS_TOKEN.Length) characters"
          
          $scriptPath = Join-Path $env:GITHUB_WORKSPACE "scripts\scaffold-entities.ps1"
          
          & $scriptPath `
            -Server "${{ env.SQL_SERVER }}" `
            -Database "${{ env.SQL_DATABASE }}" `
            -UseAzureAD
          
          Write-Host "‚úì EF Core entities scaffolded"
      
      - name: Upload scaffolded entities
        uses: actions/upload-artifact@v4
        with:
          name: scaffolded-entities
          path: src/Hartonomous.Data.Entities/
          retention-days: 7

  build-and-test:
    name: Build and Test .NET Solution
    runs-on: [self-hosted, linux]
    needs: scaffold-entities
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Download scaffolded entities
        uses: actions/download-artifact@v4
        with:
          name: scaffolded-entities
          path: src/Hartonomous.Data.Entities/
      
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
      
      - name: Display .NET Info
        run: dotnet --info
      
      - name: Restore NuGet packages
        run: dotnet restore Hartonomous.Tests.sln --verbosity minimal
        shell: pwsh
      
      - name: Build solution
        run: |
          Write-Host "Building solution in ${{ env.BUILD_CONFIGURATION }} mode..."
          dotnet build Hartonomous.Tests.sln `
            --configuration ${{ env.BUILD_CONFIGURATION }} `
            --no-restore `
            --verbosity minimal
        shell: pwsh
      
      - name: Run unit tests
        run: |
          Write-Host "Running unit tests with hybrid database testing..."
          Write-Host "Environment: CI=${{ env.CI }} (will use Docker/Testcontainers)"
          
          dotnet test tests/**/*Tests.csproj `
            --configuration ${{ env.BUILD_CONFIGURATION }} `
            --no-build `
            --collect:"XPlat Code Coverage" `
            --logger "trx;LogFileName=test-results.trx" `
            --results-directory ./TestResults `
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover
          
          Write-Host "‚úì Tests completed"
        shell: pwsh
        env:
          CI: true  # DatabaseTestBase will use Docker (Testcontainers)
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: TestResults/
          retention-days: 7
      
      - name: Build summary
        if: always()
        shell: pwsh
        run: |
          Write-Host "`n=== Build Summary ==="
          
          $testResults = Get-ChildItem -Path "TestResults" -Filter "*.trx" -Recurse | Select-Object -First 1
          
          if ($testResults) {
            [xml]$trx = Get-Content $testResults.FullName
            $counters = $trx.TestRun.ResultSummary.Counters
            
            Write-Host "Tests Total: $($counters.total)"
            Write-Host "Tests Passed: $($counters.passed)"
            Write-Host "Tests Failed: $($counters.failed)"
            Write-Host "Tests Skipped: $($counters.notExecuted)"
            
            $summary = @"
          ## Test Results
          - ‚úÖ Passed: $($counters.passed)
          - ‚ùå Failed: $($counters.failed)
          - ‚è≠Ô∏è Skipped: $($counters.notExecuted)
          - üìä Total: $($counters.total)
          "@
            
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value $summary
          }

  build-applications:
    name: Build Applications
    runs-on: [self-hosted, linux]
    needs: build-and-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download scaffolded entities
        uses: actions/download-artifact@v4
        with:
          name: scaffolded-entities
          path: src/Hartonomous.Data.Entities/
      
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
      
      - name: Restore dependencies
        run: dotnet restore Hartonomous.Tests.sln
      
      - name: Publish Hartonomous.Api
        shell: pwsh
        run: |
          Write-Host "Publishing Hartonomous.Api..."
          
          $outputPath = Join-Path $env:GITHUB_WORKSPACE "artifacts\api"
          
          dotnet publish src/Hartonomous.Api/Hartonomous.Api.csproj `
            --configuration ${{ env.BUILD_CONFIGURATION }} `
            --output $outputPath `
            --no-restore `
            /p:PublishSingleFile=false `
            /p:PublishTrimmed=false
          
          Write-Host "‚úì Hartonomous.Api published to: $outputPath"
      
      - name: Upload application artifacts
        uses: actions/upload-artifact@v4
        with:
          name: applications
          path: artifacts/
          retention-days: 7