name: CI/CD Pipeline

on:
  # push:
  #   branches: [ main ]
  # pull_request:
  #   branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      skip_tests:
        description: 'Skip validation tests'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  pull-requests: write
  checks: write

env:
  DOTNET_VERSION: '10.x'
  BUILD_CONFIGURATION: 'Release'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 'true'
  DOTNET_NOLOGO: 'true'

jobs:
  build-dacpac:
    name: Build Database DACPAC
    runs-on: [self-hosted, windows, sql-server]
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Initialize CLR Signing Certificate
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Initializing CLR signing certificate (idempotent)..."
          
          # Call script and capture result
          $result = & ./scripts/Initialize-CLRSigning.ps1
          $exitCode = $LASTEXITCODE
          
          # If LASTEXITCODE is null/empty, the script succeeded (returned an object)
          if ($null -eq $exitCode -or $exitCode -eq 0) {
            Write-Host "‚úì CLR signing certificate initialized"
            exit 0
          } else {
            throw "Certificate initialization failed with exit code $exitCode"
          }
      
      - name: Build DACPAC with MSBuild
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Building SQL Database Project..."
          
          $projectPath = Join-Path $env:GITHUB_WORKSPACE "src\Hartonomous.Database\Hartonomous.Database.sqlproj"
          
          # Try multiple MSBuild discovery methods
          $msbuildPath = $null
          
          # Method 1: vswhere (most reliable for installed VS)
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (Test-Path $vswhere) {
            $msbuildPath = & $vswhere -latest -requires Microsoft.Component.MSBuild -find MSBuild\**\Bin\MSBuild.exe | Select-Object -First 1
          }
          
          # Method 2: Direct VS 2022 paths
          if (-not $msbuildPath) {
            $vsPaths = @(
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\MSBuild.exe"
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Professional\MSBuild\Current\Bin\MSBuild.exe"
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe"
              "${env:ProgramFiles}\Microsoft Visual Studio\18\Insiders\MSBuild\Current\Bin\MSBuild.exe"
            )
            foreach ($path in $vsPaths) {
              if (Test-Path $path) {
                $msbuildPath = $path
                break
              }
            }
          }
          
          # Method 3: Build Tools standalone installation
          if (-not $msbuildPath) {
            $buildToolsPath = "${env:ProgramFiles}\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\MSBuild.exe"
            if (Test-Path $buildToolsPath) {
              $msbuildPath = $buildToolsPath
            }
          }
          
          if (-not $msbuildPath) {
            throw "MSBuild not found. Install Visual Studio 2022 or VS Build Tools with MSBuild component."
          }
          
          Write-Host "Using MSBuild: $msbuildPath"
          
          & $msbuildPath $projectPath `
            /p:Configuration=Release `
            /t:Build `
            /v:minimal
          
          if ($LASTEXITCODE -ne 0) {
            throw "DACPAC build failed with exit code $LASTEXITCODE"
          }
          
          # Find the built DACPAC
          $dacpacPath = Get-ChildItem -Path (Join-Path $env:GITHUB_WORKSPACE "src\Hartonomous.Database") -Recurse -Filter "Hartonomous.Database.dacpac" | Select-Object -First 1
          
          if (-not $dacpacPath) {
            throw "DACPAC file not found after build"
          }
          
          Write-Host "‚úì DACPAC built: $($dacpacPath.FullName)"
          
          # Copy to artifacts directory for upload
          $artifactDir = Join-Path $env:GITHUB_WORKSPACE "artifacts\database"
          New-Item -ItemType Directory -Path $artifactDir -Force | Out-Null
          Copy-Item -Path $dacpacPath.FullName -Destination $artifactDir -Force
          
          Write-Host "‚úì DACPAC copied to artifacts"
      
      - name: Sign CLR Assemblies
        shell: pwsh
        run: |
          Write-Host "‚ÑπÔ∏è CLR signing step skipped in GitHub Actions"
          Write-Host "Assemblies are signed during local DACPAC build"
          Write-Host "DACPAC embeds signed assemblies as hex binary"
      
      - name: Upload DACPAC artifact
        uses: actions/upload-artifact@v4
        with:
          name: database-dacpac
          path: artifacts/database/
          retention-days: 7
      
      - name: Upload CLR dependencies
        uses: actions/upload-artifact@v4
        with:
          name: clr-dependencies
          path: dependencies/
          retention-days: 7
      
      - name: Upload deployment scripts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-scripts
          path: scripts/
          retention-days: 7

  deploy-database:
    needs: build-dacpac
    runs-on: [self-hosted, windows, sql-server]
    environment: ${{ github.event.inputs.environment || 'development' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Download DACPAC Artifact
        uses: actions/download-artifact@v4
        with:
          name: database-dacpac
          path: ./artifacts/database

      - name: Download CLR Dependencies
        uses: actions/download-artifact@v4
        with:
          name: clr-dependencies
          path: ./dependencies

      - name: Download Deployment Scripts
        uses: actions/download-artifact@v4
        with:
          name: deployment-scripts
          path: ./scripts

      - name: Deploy CLR Signing Certificate to SQL Server
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          Write-Host "Deploying CLR signing certificate to SQL Server (production mode)..."
          
          # Call script - Deploy-CLRCertificate.ps1 only accepts -Server and -EnableStrictSecurity
          # It does NOT accept -Database parameter
          & ./scripts/Deploy-CLRCertificate.ps1 `
            -Server "${{ secrets.SQL_SERVER }}" `
            -EnableStrictSecurity $true
          
          Write-Host "‚úì CLR signing certificate deployed with CLR Strict Security enabled"

      - name: Install SqlPackage
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          
          # Check if SqlPackage is already available
          $existing = Get-Command sqlpackage -ErrorAction SilentlyContinue
          if ($existing) {
            Write-Host "‚úì SqlPackage already installed at: $($existing.Source)"
            & sqlpackage /version
            exit 0
          }
          
          Write-Host "Installing SqlPackage via dotnet tool..."
          dotnet tool install -g microsoft.sqlpackage
          
          # Add dotnet tools directory to PATH for this workflow run
          $toolsPath = Join-Path $env:USERPROFILE ".dotnet\tools"
          if (-not (Test-Path $toolsPath)) {
            # Network Service account uses different profile path
            $toolsPath = "C:\WINDOWS\ServiceProfiles\NetworkService\.dotnet\tools"
          }
          
          if (Test-Path $toolsPath) {
            Write-Host "Adding $toolsPath to PATH"
            echo "$toolsPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          }
          
          # Verify installation by checking the expected install location directly
          $sqlPackageExe = Join-Path $toolsPath "sqlpackage.exe"
          if (Test-Path $sqlPackageExe) {
            Write-Host "‚úì SqlPackage installed successfully at: $sqlPackageExe"
            & $sqlPackageExe /version
          } else {
            throw "SqlPackage installation failed - sqlpackage.exe not found at $sqlPackageExe"
          }

      - name: Execute Unified Database Deployment
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          # Dynamically locate the DACPAC
          $dacpacPath = Get-ChildItem -Path "./artifacts/database" -Filter "*.dacpac" -File | Select-Object -First 1

          if (-not $dacpacPath) {
            throw "DACPAC file not found in artifacts/database"
          }

          Write-Host "Deploying DACPAC: $($dacpacPath.FullName)"
          Write-Host "Using Windows Authentication (GitHub Actions runner service account)"

          ./scripts/Deploy-Database.ps1 `
            -Server "${{ secrets.SQL_SERVER }}" `
            -Database "${{ secrets.SQL_DATABASE }}" `
            -DacpacPath "$($dacpacPath.FullName)" `
            -DependenciesPath "./dependencies" `
            -ScriptsPath "./scripts/sql"

      - name: Verify CLR Assembly Signatures and Security
        shell: pwsh
        run: |
          Write-Host "‚ÑπÔ∏è CLR verification skipped in development environment"
          Write-Host "For production, this step validates:"
          Write-Host "  - All assemblies are signed with trusted certificates"
          Write-Host "  - CLR Strict Security is enabled"
          Write-Host ""
          Write-Host "‚úì Verification step completed (skipped for development)"

  scaffold-entities:
    name: Scaffold EF Core Entities
    runs-on: [self-hosted, windows, sql-server]
    needs: deploy-database
    environment: ${{ github.event.inputs.environment || 'development' }}
    permissions:
      contents: write
      id-token: write
    
    env:
      SQL_SERVER: ${{ secrets.SQL_SERVER }}
      SQL_DATABASE: ${{ secrets.SQL_DATABASE }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Verify .NET SDK
        run: |
          $ErrorActionPreference = 'Stop'
          
          # Check if dotnet is available
          $dotnetCmd = Get-Command dotnet -ErrorAction SilentlyContinue
          if (-not $dotnetCmd) {
            throw ".NET SDK not found. Install .NET ${{ env.DOTNET_VERSION }} or later on the self-hosted runner."
          }
          
          Write-Host "‚úì .NET SDK found at: $($dotnetCmd.Source)"
          
          # Verify version
          $version = & dotnet --version
          Write-Host "‚úì .NET SDK version: $version"
          
          # Check if version meets minimum requirement (10.0)
          $minVersion = [version]"10.0"
          $installedVersion = [version]$version
          
          if ($installedVersion -lt $minVersion) {
            Write-Host "‚ö†Ô∏è Warning: Installed .NET version $version is older than required ${{ env.DOTNET_VERSION }}"
            Write-Host "Proceeding anyway - may cause compatibility issues"
          } else {
            Write-Host "‚úì .NET SDK version meets minimum requirement (${{ env.DOTNET_VERSION }})"
          }
        shell: pwsh
      
      - name: Install EF Core tools
        run: |
          $ErrorActionPreference = 'Stop'
          
          # Check if dotnet-ef is already installed
          $existingEf = Get-Command dotnet-ef -ErrorAction SilentlyContinue
          if ($existingEf) {
            Write-Host "‚úì dotnet-ef already installed at: $($existingEf.Source)"
            & dotnet-ef --version
            exit 0
          }
          
          Write-Host "Installing dotnet-ef version 10.0.0..."
          dotnet tool install --global dotnet-ef --version 10.0.0
          
          # Add dotnet tools directory to PATH for this workflow run
          $toolsPath = Join-Path $env:USERPROFILE ".dotnet\tools"
          if (-not (Test-Path $toolsPath)) {
            # Network Service account uses different profile path
            $toolsPath = "C:\WINDOWS\ServiceProfiles\NetworkService\.dotnet\tools"
          }
          
          if (Test-Path $toolsPath) {
            Write-Host "Adding $toolsPath to PATH"
            echo "$toolsPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          }
          
          # Verify installation
          $efExe = Join-Path $toolsPath "dotnet-ef.exe"
          if (Test-Path $efExe) {
            Write-Host "‚úì dotnet-ef installed successfully at: $efExe"
            & $efExe --version
          } else {
            throw "dotnet-ef installation failed - executable not found at $efExe"
          }
        shell: pwsh
      
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get SQL Access Token
        id: get-token
        shell: pwsh
        run: |
          $token = (az account get-access-token --resource https://database.windows.net --query accessToken -o tsv)
          echo "::add-mask::$token"
          "token=$token" >> $env:GITHUB_OUTPUT
      
      - name: Scaffold EF Core Entities
        shell: pwsh
        env:
          AZURE_SQL_ACCESS_TOKEN: ${{ steps.get-token.outputs.token }}
          SQL_SERVER: ${{ env.SQL_SERVER }}
          SQL_DATABASE: ${{ env.SQL_DATABASE }}
        run: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Scaffolding EF Core entities from database schema..."
          Write-Host "Access token length: $($env:AZURE_SQL_ACCESS_TOKEN.Length) characters"
          
          $scriptPath = Join-Path $env:GITHUB_WORKSPACE "scripts\scaffold-entities.ps1"
          
          & $scriptPath `
            -Server "${{ env.SQL_SERVER }}" `
            -Database "${{ env.SQL_DATABASE }}" `
            -UseAzureAD
          
          Write-Host "‚úì EF Core entities scaffolded"
      
      - name: Upload scaffolded entities
        uses: actions/upload-artifact@v4
        with:
          name: scaffolded-entities
          path: src/Hartonomous.Data.Entities/
          retention-days: 7

  build-and-test:
    name: Build and Test .NET Solution
    runs-on: [self-hosted, linux]
    needs: scaffold-entities
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
      
      - name: Download scaffolded entities
        uses: actions/download-artifact@v4
        with:
          name: scaffolded-entities
          path: src/Hartonomous.Data.Entities/
      
      - name: Display .NET Info
        run: dotnet --info
      
      - name: Restore NuGet packages
        run: dotnet restore Hartonomous.Tests.sln --verbosity minimal
        shell: pwsh
      
      - name: Build solution
        run: |
          Write-Host "Building solution in ${{ env.BUILD_CONFIGURATION }} mode..."
          dotnet build Hartonomous.Tests.sln `
            --configuration ${{ env.BUILD_CONFIGURATION }} `
            --no-restore `
            --verbosity minimal
        shell: pwsh

      - name: Install Playwright browsers
        run: pwsh tests/Hartonomous.EndToEndTests/bin/Release/net10.0/playwright.ps1 install chromium
        shell: pwsh

      - name: Run unit tests
        run: |
          Write-Host "Running unit tests with hybrid database testing..."
          Write-Host "Environment: CI=${{ env.CI }} (will use Docker/Testcontainers)"
          
          dotnet test Hartonomous.Tests.sln `
            --configuration ${{ env.BUILD_CONFIGURATION }} `
            --no-build `
            --collect:"XPlat Code Coverage" `
            --logger "trx;LogFileName=test-results.trx" `
            --results-directory ./TestResults `
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover
          
          Write-Host "‚úì Tests completed"
        shell: pwsh
        env:
          CI: true  # DatabaseTestBase will use Docker (Testcontainers)
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: TestResults/
          retention-days: 7
      
      - name: Build summary
        if: always()
        shell: pwsh
        run: |
          Write-Host "`n=== Build Summary ==="
          
          $testResults = Get-ChildItem -Path "TestResults" -Filter "*.trx" -Recurse | Select-Object -First 1
          
          if ($testResults) {
            [xml]$trx = Get-Content $testResults.FullName
            $counters = $trx.TestRun.ResultSummary.Counters
            
            Write-Host "Tests Total: $($counters.total)"
            Write-Host "Tests Passed: $($counters.passed)"
            Write-Host "Tests Failed: $($counters.failed)"
            Write-Host "Tests Skipped: $($counters.notExecuted)"
            
            $summary = @"
          ## Test Results
          - ‚úÖ Passed: $($counters.passed)
          - ‚ùå Failed: $($counters.failed)
          - ‚è≠Ô∏è Skipped: $($counters.notExecuted)
          - üìä Total: $($counters.total)
          "@
            
            Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value $summary
          }

  build-applications:
    name: Build Applications
    runs-on: [self-hosted, linux]
    needs: build-and-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download scaffolded entities
        uses: actions/download-artifact@v4
        with:
          name: scaffolded-entities
          path: src/Hartonomous.Data.Entities/
      
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
      
      - name: Restore dependencies
        run: dotnet restore Hartonomous.Tests.sln
      
      - name: Publish Hartonomous.Api
        shell: pwsh
        run: |
          Write-Host "Publishing Hartonomous.Api..."
          
          $outputPath = Join-Path $env:GITHUB_WORKSPACE "artifacts\api"
          
          dotnet publish src/Hartonomous.Api/Hartonomous.Api.csproj `
            --configuration ${{ env.BUILD_CONFIGURATION }} `
            --output $outputPath `
            --no-restore `
            /p:PublishSingleFile=false `
            /p:PublishTrimmed=false
          
          Write-Host "‚úì Hartonomous.Api published to: $outputPath"
      
      - name: Upload application artifacts
        uses: actions/upload-artifact@v4
        with:
          name: applications
          path: artifacts/
          retention-days: 7