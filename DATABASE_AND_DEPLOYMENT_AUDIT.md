# DATABASE AND DEPLOYMENT AUDIT

**Generated**: November 11, 2025  
**Purpose**: Assess SQL/EF Core/Database deployment mess created by half-assed AI agent work  
**Methodology**: File inventory + EF Core analysis + deployment script review + consistency validation

---

## Executive Summary

**Current State**: ⚠️ **FRAGMENTED** - Database deployment is split across 109 SQL files, 1 EF Core migration, and multiple deployment strategies with inconsistent organization.

**Critical Findings**:
- ⚠️ **109 SQL script files** scattered across 7 subdirectories with unclear deployment order
- ⚠️ **1 monolithic EF Core migration** (`20251110135023_FullSchema`) - "dump everything in one migration" anti-pattern
- ⚠️ **12 TODO/PLACEHOLDER/NOTE comments** in SQL scripts indicating incomplete work
- ⚠️ **Schema duplication**: `sql/ef-core/Hartonomous.Schema.sql` duplicates EF Core migration output (8,000+ lines)
- ⚠️ **3 different billing table implementations**: `BillingUsageLedger.sql`, `BillingUsageLedger_InMemory.sql`, `BillingUsageLedger_Migrate_to_Ledger.sql`
- ⚠️ **Inconsistent naming**: Mix of PascalCase (EF Core) and snake_case procedures (`sp_*` vs `dbo.*`)
- ✅ **deploy-database-unified.ps1** is well-structured but references scripts that don't all exist
- ✅ **EF Core 10 + SQL Server 2025 features** correctly configured (VECTOR, spatial, temporal tables)

**Impact**: Deployment confusion, schema drift risk, difficult to maintain, unclear "source of truth" for database schema.

---

## 1. SQL Script Inventory (109 Files)

### Directory Structure

```
sql/
├── cdc/                              # 1 file  - CDC configuration
├── ef-core/                          # 1 file  - DUPLICATE schema from EF migrations
├── procedures/                       # 52 files - Stored procedures, functions, CLR bindings
├── tables/                           # 42 files - Table definitions (some duplicate EF Core)
├── types/                            # 2 files  - User-defined types (provenance.*)
├── verification/                     # 2 files  - Validation scripts
├── *.sql (root)                      # 9 files  - Setup scripts (FILESTREAM, indexes, etc.)
```

### Schema Duplication Analysis

**CRITICAL ISSUE**: `sql/ef-core/Hartonomous.Schema.sql` (8,136 lines) is a **DUMP** of EF Core migration output.

**Problems**:
1. **Redundant**: Already generated by `dotnet ef migrations script`
2. **Out of sync risk**: If EF migrations change, this file becomes stale
3. **Manual maintenance burden**: 8,000+ lines that should be auto-generated
4. **Version confusion**: No indication which migration version this represents

**Recommendation**: **DELETE** this file. Use EF Core migration scripts directly.

### Table Definition Duplication

**Duplicates Between EF Core and Manual SQL**:

| Table | EF Core Migration | Manual SQL Script | Status |
|-------|------------------|-------------------|--------|
| **Atoms** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.Atoms.sql` | ⚠️ DUPLICATE |
| **AtomEmbeddings** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.AtomEmbeddings.sql` | ⚠️ DUPLICATE |
| **AtomPayloadStore** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.AtomPayloadStore.sql` | ⚠️ DUPLICATE |
| **BillingUsageLedger** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.BillingUsageLedger.sql` | ⚠️ DUPLICATE |
| **BillingUsageLedger** | ❌ Not in EF | ❌ `tables/dbo.BillingUsageLedger_InMemory.sql` | ⚠️ ALTERNATIVE IMPL |
| **BillingUsageLedger** | ❌ Not in EF | ❌ `tables/dbo.BillingUsageLedger_Migrate_to_Ledger.sql` | ⚠️ MIGRATION SCRIPT |
| **AutonomousImprovementHistory** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.AutonomousImprovementHistory.sql` | ⚠️ DUPLICATE |
| **InferenceCache** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.InferenceCache.sql` | ⚠️ DUPLICATE |
| **graph.AtomGraphNodes** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/graph.AtomGraphNodes.sql` | ⚠️ DUPLICATE |
| **graph.AtomGraphEdges** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/graph.AtomGraphEdges.sql` | ⚠️ DUPLICATE |
| **ModelStructure** (Models/ModelLayers) | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.ModelStructure.sql` | ⚠️ DUPLICATE |
| **TenantSecurityPolicy** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.TenantSecurityPolicy.sql` | ⚠️ DUPLICATE |
| **TestResults** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.TestResults.sql` | ⚠️ DUPLICATE |
| **TokenVocabulary** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.TokenVocabulary.sql` | ⚠️ DUPLICATE |
| **Weights** | ✅ 20251110135023_FullSchema.cs | ❌ `tables/dbo.Weights.sql` | ⚠️ DUPLICATE |

**Impact**: **15 duplicate table definitions** risk schema drift if one is updated but not the other.

### Tables NOT in EF Core (Legitimate Manual SQL)

| Table/Script | Purpose | EF Core Managed? | Status |
|-------------|---------|------------------|--------|
| **Attention.AttentionGenerationTables.sql** | AttentionGenerationLog, AttentionInferenceResults, TransformerInferenceResults | ❌ No | ✅ LEGITIMATE |
| **Reasoning.ReasoningFrameworkTables.sql** | ReasoningChains, SelfConsistencyResults, MultiPathReasoning | ❌ No | ✅ LEGITIMATE |
| **Stream.StreamOrchestrationTables.sql** | StreamOrchestrationResults, StreamFusionResults, EventGenerationResults, EventAtoms | ❌ No | ✅ LEGITIMATE |
| **Provenance.ProvenanceTrackingTables.sql** | OperationProvenance, ProvenanceValidationResults, ProvenanceAuditResults | ❌ No | ✅ LEGITIMATE |
| **provenance.Concepts.sql** | Concepts, AtomConcepts, ConceptEvolution | ❌ No (partial) | ⚠️ MIXED (Concepts is in EF) |
| **dbo.SpatialLandmarks.sql** | SpatialLandmarks | ❌ No | ✅ LEGITIMATE |
| **dbo.InferenceTracking.sql** | InferenceRequests, InferenceSteps | ⚠️ Partial (InferenceRequests in EF) | ⚠️ MIXED |
| **dbo.PendingActions.sql** | PendingActions | ❌ No | ✅ LEGITIMATE |
| **dbo.AutonomousComputeJobs.sql** | AutonomousComputeJobs | ❌ No | ✅ LEGITIMATE |
| **dbo.TensorAtomPayloads.sql** | TensorAtomPayloads | ❌ No | ✅ LEGITIMATE |
| **dbo.SessionPaths.sql** | SessionPaths | ❌ No | ✅ LEGITIMATE |

**Analysis**: **11 tables** genuinely need manual SQL (advanced features like Service Broker, CLR types, graph). **15 tables** are unnecessary duplicates.

### Stored Procedures and Functions (52 Files)

**Organization**: Grouped by functional area (good practice!)

**Categories**:
- **CLR Bindings** (2 files): `Common.ClrBindings.sql`, `Autonomy.FileSystemBindings.sql` - CLR function wrappers
- **Vector Operations** (3 files): `Functions.VectorOperations.sql`, `Functions.BinaryToRealConversion.sql`, `Functions.AggregateVectorOperations.sql`
- **Spatial** (3 files): `Spatial.ProjectionSystem.sql`, `Spatial.LargeLineStringFunctions.sql`, `Common.CreateSpatialIndexes.sql`
- **Inference** (6 files): `Inference.VectorSearchSuite.sql`, `Inference.SpatialGenerationSuite.sql`, `Inference.AdvancedAnalytics.sql`, etc.
- **Generation** (4 files): `Generation.AudioFromPrompt.sql`, `Generation.ImageFromPrompt.sql`, `Generation.VideoFromPrompt.sql`, `Generation.TextFromVector.sql`
- **Atomization** (7 files): `dbo.sp_AtomizeAudio.sql`, `dbo.sp_AtomizeImage.sql`, `dbo.sp_AtomizeCode.sql`, etc.
- **Autonomy** (2 files): `Autonomy.SelfImprovement.sql`, `Autonomy.FileSystemBindings.sql`
- **Analysis** (2 files): `Analysis.WeightHistory.sql`, `Admin.WeightRollback.sql`
- **Provenance** (4 files): `Provenance.ProvenanceTracking.sql`, `provenance.AtomicStreamFactory.sql`, etc.
- **Graph** (1 file): `Graph.AtomSurface.sql`
- **Billing** (2 files): `Billing.InsertUsageRecord_Native.sql`, `dbo.BillingFunctions.sql`
- **Agent Framework** (1 file): `dbo.AgentFramework.sql`
- **Misc** (15 files): Various helpers, search, deduplication, messaging

**Issues**:
- ❌ **Duplicate CLR function definitions**: `Common.ClrBindings.sql` (441 lines) defines 40+ CLR functions
- ⚠️ **Inconsistent naming**: `dbo.sp_AtomizeAudio` vs `Functions.VectorOperations` (no `dbo.` prefix)
- ⚠️ **12 TODO/PLACEHOLDER/NOTE comments** indicating incomplete work

### Temporal Table Management (3 Files)

| File | Purpose | Status |
|------|---------|--------|
| **TensorAtomCoefficients_Temporal.sql** | Enable temporal on TensorAtomCoefficients with 90-day retention + columnstore | ✅ COMPLETE |
| **Temporal_Tables_Add_Retention_and_Columnstore.sql** | Add retention policies to TensorAtomCoefficients and Weights history tables | ✅ COMPLETE |
| **Temporal_Tables_Evaluation.sql** | Enable/disable temporal on ModelLayers and TensorAtoms (experimental) | ⚠️ EXPERIMENTAL |

**Analysis**: Temporal table setup is well-structured. **TensorAtomCoefficients** and **Weights** have production-ready temporal configurations.

---

## 2. EF Core Migration Analysis

### Migration Status

**Total Migrations**: **1**  
**Current Migration**: `20251110135023_FullSchema`

```bash
$ dotnet ef migrations list --project src/Hartonomous.Data
20251110135023_FullSchema
```

### Monolithic Migration Problem

**Issue**: The **ENTIRE** database schema (60+ tables) is in ONE migration file.

**Problems**:
1. **Difficult to review**: 2,000+ lines of migration code
2. **No history**: Can't track when/why specific tables were added
3. **Rollback nightmare**: Can't selectively rollback changes
4. **Merge conflicts**: Every schema change touches the same huge file
5. **Lost intent**: No commit messages explaining design decisions

**Recommended Fix**: Break into logical migrations:
- Migration 1: Core Atom substrate (Atoms, AtomEmbeddings, TensorAtoms)
- Migration 2: Model structure (Models, ModelLayers, Weights)
- Migration 3: Billing infrastructure (BillingRatePlans, BillingUsageLedger)
- Migration 4: Multi-modal data (Images, Videos, Audio, TextDocuments)
- Migration 5: Provenance and inference tracking
- Migration 6: Graph schema (AtomGraphNodes, AtomGraphEdges)
- Migration 7: Caching and performance (InferenceCache, CachedActivations)

**However**: This is **NOT** recommended now due to production deployment risk. Document as technical debt.

### DbContext Configuration Analysis

**File**: `src/Hartonomous.Data/HartonomousDbContext.cs` (107 lines)

**Positives**:
- ✅ Well-organized DbSet properties (22 DbSets)
- ✅ Applies configurations from assembly (good separation of concerns)
- ✅ Multi-schema support via per-configuration schema settings
- ✅ DateTime conventions (UTC, DATETIME2)
- ✅ DateOnly convention (DATE column type)

**Issues**:
- ⚠️ **Missing DbSets** for tables in manual SQL scripts (11 tables not exposed via EF Core)
- ⚠️ **No documentation**: Comments don't explain why some tables are in EF and others in SQL

**Missing DbSets** (tables exist in SQL but not in EF Core):
- `AttentionGenerationLog`, `AttentionInferenceResults`, `TransformerInferenceResults`
- `ReasoningChains`, `SelfConsistencyResults`, `MultiPathReasoning`
- `StreamOrchestrationResults`, `StreamFusionResults`, `EventGenerationResults`, `EventAtoms`
- `OperationProvenance`, `ProvenanceValidationResults`, `ProvenanceAuditResults`
- `SpatialLandmarks`, `PendingActions`, `AutonomousComputeJobs`, `SessionPaths`
- `TensorAtomPayloads`

**Recommendation**: Document which tables are intentionally excluded from EF Core (e.g., Service Broker tables, CLR-heavy tables) vs which are missing by accident.

### Entity Configurations (Hartonomous.Data/Configurations/)

**Organization**: Good! Each entity has its own configuration class.

**Sample Analysis** (from grep results):

**Atom Configuration** (`AtomConfiguration.cs`):
- ✅ Correctly maps `Metadata` and `Semantics` as JSON columns (`nvarchar(max)`)
- ✅ Spatial index on `geometry::STGeomFromWKB(EmbeddingGeometry, 0)` (SqlGeometry)
- ✅ Relationships to AtomEmbeddings, AtomRelations, TensorAtoms
- ⚠️ **NOT using SQL Server 2025 native JSON type** (still `nvarchar(max)`)

**AtomEmbedding Configuration** (`AtomEmbeddingConfiguration.cs`):
- ✅ Spatial bucket indexing for vector search optimization
- ✅ Relationships to Atom, Model, AtomEmbeddingComponents
- ⚠️ **NOT using SQL Server 2025 native VECTOR type** (still VARBINARY)

**AtomGraphNode/AtomGraphEdge Configuration**:
- ✅ SQL Graph table syntax (`AsNodes()`, `AsEdges()`)
- ✅ JSON metadata columns
- ✅ Relationships configured

**Issue**: EF Core 10 supports native `VECTOR` and `JSON` types, but configurations still use legacy `VARBINARY(MAX)` and `nvarchar(max)`. This is **EXPECTED** since migrating to native types requires manual migration (breaking change).

---

## 3. Deployment Script Analysis

### deploy-database-unified.ps1 (811 lines)

**Purpose**: "Single deployment solution" for both HART-SERVER (Linux) and HART-DESKTOP (Windows).

**Architecture** (from script header):
1. EF Core migrations create domain tables
2. SQL scripts add advanced features (CLR, Service Broker, FILESTREAM, Graph)
3. Stored procedures provide business logic
4. CLR assemblies for vector/geometry operations

**Deployment Order**:
1. Prerequisites (databases, filegroups, schemas)
2. EF Core migrations (domain tables)
3. CLR assemblies (UNSAFE, with dependencies)
4. SQL types/tables (advanced features not in EF)
5. Service Broker messaging infrastructure
6. Stored procedures (depends on tables + CLR)
7. Verification tests

**Positives**:
- ✅ Well-documented header explaining architecture decisions
- ✅ Idempotent operations (checks before creating)
- ✅ Rollback support via transactions
- ✅ Validation checks after deployment
- ✅ Supports Windows and Linux paths
- ✅ Dry-run mode for testing
- ✅ Verbose logging
- ✅ CLR dependency management

**Issues Identified**:

#### Issue 1: Hardcoded Script Paths

**Problem**: Script references **specific SQL files** that may not exist or may be outdated.

```powershell
$script:SqlPaths = @{
    AdvancedTables = @(
        "sql\tables\Attention.AttentionGenerationTables.sql"
        "sql\tables\Reasoning.ReasoningFrameworkTables.sql"
        # ... 13 more hardcoded paths
    )
    GraphTables = @(
        "sql\tables\graph.AtomGraphNodes.sql"
        "sql\tables\graph.AtomGraphEdges.sql"
    )
    ServiceBroker = @(
        "scripts\setup-service-broker.sql"
    )
}
```

**Impact**: If you add a new table script, deployment script won't include it unless manually updated.

**Recommendation**: Auto-discover scripts by pattern matching or use a manifest file.

#### Issue 2: Duplicate Table Deployment Risk

**Problem**: Deploy script executes **both** EF Core migrations AND manual SQL table scripts for the same tables.

**Example**: `Atoms` table:
1. Created by EF Core migration `20251110135023_FullSchema`
2. Also referenced in `sql/tables/dbo.Atoms.sql`

**Deployment Order**:
```
Step 2: Run EF migrations → Creates Atoms table
Step 4: Run SQL scripts → Tries to create Atoms table again (IF NOT EXISTS check)
```

**Impact**: Confusing schema ownership. Is EF Core or SQL the "source of truth"?

**Recommendation**: Remove duplicate SQL scripts for tables managed by EF Core.

#### Issue 3: CLR Deployment Complexity

**Problem**: CLR assemblies have complex dependency chains.

```powershell
# CLR deployment order (from script):
1. System.Memory.dll
2. System.Buffers.dll
3. System.Runtime.CompilerServices.Unsafe.dll
4. MathNet.Numerics.dll
5. Newtonsoft.Json.dll
6. Microsoft.SqlServer.Types.dll
7. System.Numerics.Vectors.dll
8. SqlClrFunctions.dll (main assembly)
```

**Issues**:
- ❌ **No version checking**: Deploying v1.0.0 on top of v2.0.0 could break
- ❌ **No dependency validation**: Script doesn't verify all dependencies are correct versions
- ❌ **UNSAFE permission required**: Security risk if not properly locked down

**Recommendation**: Add version checking and manifest validation.

#### Issue 4: Service Broker Setup Missing

**Problem**: Script references `scripts\setup-service-broker.sql` but file location verification is commented out.

**Impact**: Service Broker deployment may fail silently.

#### Issue 5: No Verification of CLR Functions

**Problem**: Script deploys CLR assemblies and SQL functions, but doesn't **TEST** that functions work.

**Example**: After deploying `clr_VectorDotProduct`, script should verify:
```sql
SELECT dbo.clr_VectorDotProduct(@test_vector1, @test_vector2)
-- Expected: 0.95 or similar
```

**Recommendation**: Add smoke tests for critical CLR functions.

---

## 4. SQL CLR Deployment

### CLR Assembly Inventory

**Primary Assembly**: `SqlClrFunctions.dll` (.NET Framework 4.8.1)

**Dependencies** (deployed as SAFE or UNSAFE):
- `System.Memory.dll`
- `System.Buffers.dll`
- `System.Runtime.CompilerServices.Unsafe.dll`
- `MathNet.Numerics.dll`
- `Newtonsoft.Json.dll`
- `Microsoft.SqlServer.Types.dll`
- `System.Numerics.Vectors.dll`

### CLR Function Bindings (40+ Functions)

**File**: `sql/procedures/Common.ClrBindings.sql` (441 lines)

**Vector Operations** (12 functions):
- `clr_VectorDotProduct`, `clr_VectorCosineSimilarity`, `clr_VectorEuclideanDistance`
- `clr_VectorNormalize`, `clr_VectorSoftmax`, `clr_VectorArgMax`
- `clr_VectorAdd`, `clr_VectorSubtract`, `clr_VectorScale`, `clr_VectorLerp`, `clr_VectorNorm`
- `clr_SemanticFeaturesJson`

**Image Processing** (7 functions):
- `clr_ImageToPointCloud`, `clr_ImageAverageColor`, `clr_ImageLuminanceHistogram`
- `clr_GenerateImagePatches`, `clr_GenerateImageGeometry`, `clr_GenerateImageFromShapes`
- `clr_DeconstructImageToPatches`

**Audio Processing** (6 functions):
- `clr_AudioToWaveform`, `clr_AudioComputeRms`, `clr_AudioComputePeak`
- `clr_AudioDownsample`, `clr_GenerateHarmonicTone`, `clr_GenerateAudioFromSpatialSignature`

**Spatial/Geometry** (4 functions):
- `clr_ProjectToPoint`, `clr_CreateGeometryPointWithImportance`
- `clr_GenerateSequence`, `clr_GenerateTextSequence`

**Advanced** (11 functions):
- `clr_GenerateCodeAstVector`, `clr_ParseModelLayer`, `clr_SynthesizeModelLayer`
- `clr_SvdDecompose`, `clr_ReconstructFromSVD`
- `clr_StoreTensorAtomPayload`, `clr_GetTensorAtomPayload`
- `clr_JsonFloatArrayToBytes`, `fn_DiscoverConcepts`, `fn_BindConcepts`

**File System** (7 functions - **UNSAFE PERMISSION REQUIRED**):
- `clr_WriteFileBytes`, `clr_WriteFileText`, `clr_ReadFileBytes`, `clr_ReadFileText`
- `clr_ExecuteShellCommand`, `clr_FileExists`, `clr_DirectoryExists`, `clr_DeleteFile`

**Provenance** (2 functions):
- `provenance.clr_CreateAtomicStream`, `provenance.clr_AppendAtomicStreamSegment`, `provenance.clr_AtomicStreamSegments`

### Issues with CLR Deployment

#### Issue 1: Duplicate Function Definitions

**Problem**: CLR functions are defined in **BOTH**:
1. `sql/procedures/Common.ClrBindings.sql` (40+ functions)
2. Individual procedure files (e.g., `provenance.AtomicStreamFactory.sql`, `dbo.fn_DiscoverConcepts.sql`)

**Example Duplicate**:
- `Common.ClrBindings.sql` line 194: `CREATE FUNCTION dbo.clr_SemanticFeaturesJson`
- `Common.ClrBindings.sql` line 54: `CREATE FUNCTION dbo.clr_SemanticFeaturesJson` (SAME FUNCTION TWICE!)

**Impact**: Deployment script may create function twice, causing errors.

#### Issue 2: Missing CLR Functions

**Referenced in Procedures but NOT in `Common.ClrBindings.sql`**:
- `clr_BytesToFloatArrayJson` (referenced in `dbo.sp_ExtractStudentModel.sql` line 123)

**Impact**: Procedure will fail at runtime with "function not found" error.

#### Issue 3: UNSAFE CLR Permission Documentation

**Context**: File system and OS integration functions require `UNSAFE` CLR permission.

**Functions with UNSAFE**:
- `clr_WriteFileBytes`, `clr_WriteFileText`, `clr_ReadFileBytes`, `clr_ReadFileText`
- `clr_ExecuteShellCommand` (OS command execution for autonomous operations)
- `clr_DeleteFile`

**Deployment Requirements**:
- ✅ **On-Premise Only**: UNSAFE CLR assemblies cannot be deployed to Azure SQL Database
- ✅ **Terms of Service**: Users accept security implications for autonomous functionality
- ✅ **SQL Server Configuration**: Requires `TRUSTWORTHY ON` or certificate signing
- ⚠️ **Network Isolation**: Recommend network segmentation for SQL Server

**Recommendation**: Document UNSAFE CLR as architectural requirement, add deployment prerequisites section.

---

## 5. Schema Consistency Validation

### SQL Server 2025 Feature Usage

#### Native VECTOR Type

**EF Core Configuration**: ❌ NOT USED (still VARBINARY(MAX))  
**Manual SQL Scripts**: ❌ NOT USED  
**CLR Functions**: ✅ Work with VARBINARY(MAX) (compatible)

**Status**: **NOT MIGRATED**. EF Core 10 supports native `VECTOR` but schema still uses legacy binary format.

**Migration Path**:
1. Create EF Core migration to change `AtomEmbeddings.Embedding` from `VARBINARY(MAX)` to `VECTOR(1536)`
2. Update CLR functions to accept `SqlVector<float>` instead of `VARBINARY(MAX)`
3. Test vector operations (dotnet product, cosine similarity)
4. Deploy to production (breaking change - requires redeployment)

#### Native JSON Type

**EF Core Configuration**: ❌ NOT USED (still `nvarchar(max)`)  
**Manual SQL Scripts**: ❌ NOT USED  
**Procedures**: ✅ Use `JSON_VALUE`, `OPENJSON` (compatible with both)

**Status**: **NOT MIGRATED**. EF Core 10 supports native `json` type but schema still uses `nvarchar(max)`.

**Migration Path**:
1. Enable compatibility level 170 or `UseAzureSql()` in DbContext
2. Create migration (automatic conversion `nvarchar(max)` → `json`)
3. Test JSON queries (`JSON_VALUE`, `JSON_QUERY`, `JSON_MODIFY`)
4. Deploy (breaking change - requires SQL Server 2025)

**Affected Columns**:
- `Atoms.Metadata`, `Atoms.Semantics` (nvarchar(max) JSON)
- `graph.AtomGraphNodes.Metadata` (nvarchar(max) JSON)
- `graph.AtomGraphEdges.Metadata` (nvarchar(max) JSON)

#### Spatial Indexes

**EF Core Configuration**: ✅ Used (`SpatialBucket` indexing on `AtomEmbeddings`)  
**Manual SQL Scripts**: ✅ `Common.CreateSpatialIndexes.sql`, `Setup_Vector_Indexes.sql`  
**CLR Functions**: ✅ `SqlGeometry` functions (image geometry, point clouds)

**Status**: ✅ **IMPLEMENTED**. Spatial indexes are correctly configured.

**Issues**:
- ⚠️ **Duplicate index definitions**: EF Core creates indexes, manual SQL scripts recreate them
- ⚠️ **No index maintenance**: Missing `REORGANIZE`/`REBUILD` automation

#### Temporal Tables

**EF Core Configuration**: ✅ `TensorAtomCoefficients` has temporal configuration  
**Manual SQL Scripts**: ✅ 3 temporal table scripts  
**Status**: ✅ **IMPLEMENTED** for `TensorAtomCoefficients` and `Weights`.

**Coverage**:
- ✅ `TensorAtomCoefficients` - 90-day retention + columnstore
- ✅ `Weights` - Retention policy configured
- ⚠️ `ModelLayers`, `TensorAtoms` - Experimental (in evaluation script)

#### Columnstore Indexes

**EF Core Configuration**: ❌ NOT POSSIBLE (EF Core doesn't support columnstore configuration)  
**Manual SQL Scripts**: ✅ `Optimize_ColumnstoreCompression.sql`  
**Status**: ✅ **IMPLEMENTED** for history tables.

**Coverage**:
- ✅ `TensorAtomCoefficients_History` - Non-clustered columnstore
- ✅ `Weights_History` - Non-clustered columnstore
- ⚠️ `BillingUsageLedger`, `AutonomousImprovementHistory` - Page/row compression only (not columnstore)

**Recommendation**: Add columnstore to `BillingUsageLedger` and `AutonomousImprovementHistory` (high-volume OLTP + analytics workload).

---

## 6. Deployment Process Maturity Assessment

### Current Deployment Workflow

**Local Development**:
```powershell
1. dotnet ef migrations add <name> --project src/Hartonomous.Data
2. dotnet ef database update --project src/Hartonomous.Data
3. Manually run SQL scripts for CLR, procedures, Service Broker
```

**Production (HART-SERVER)**:
```powershell
1. ./scripts/deploy-database-unified.ps1 -Server "localhost" -Database "Hartonomous"
2. Manual verification via SQL queries
3. Hope nothing broke
```

### Maturity Level: **2 out of 5** (Developing)

**Maturity Scale**:
1. **Ad-hoc** - Manual SQL scripts, no version control
2. **Developing** - Scripts in version control, some automation ← **CURRENT STATE**
3. **Defined** - Automated deployment, rollback support, validation
4. **Managed** - CI/CD integration, automated testing, drift detection
5. **Optimized** - Zero-downtime deployments, blue-green, schema versioning

**Gaps**:
- ❌ **No CI/CD integration**: Deployments are manual
- ❌ **No automated testing**: No post-deployment validation suite
- ❌ **No schema drift detection**: EF Core and manual SQL can diverge
- ❌ **No rollback automation**: Rollback requires manual script execution
- ❌ **No deployment approval workflow**: Anyone can run deploy script
- ⚠️ **Limited verification**: `SystemVerification.sql` exists but not comprehensive
- ⚠️ **No deployment metrics**: No tracking of deployment duration, success rate, failures

---

## 7. Critical Issues Summary

### P0: Critical (Fix Immediately)

1. **Schema Duplication (15 Tables)**
   - **Problem**: Tables defined in BOTH EF Core migrations and manual SQL scripts
   - **Impact**: Schema drift, unclear source of truth, deployment confusion
   - **Fix**: Delete manual SQL scripts for tables managed by EF Core
   - **Effort**: 2 days

2. **Missing CLR Function (`clr_BytesToFloatArrayJson`)**
   - **Problem**: Procedure references function that doesn't exist
   - **Impact**: Runtime error when calling `dbo.sp_ExtractStudentModel`
   - **Fix**: Implement function or remove reference
   - **Effort**: 4 hours

3. **UNSAFE CLR Deployment Prerequisites Documentation**
   - **Problem**: UNSAFE CLR requirements not documented in deployment guide
   - **Impact**: Deployment failures, unclear security model
   - **Fix**: Document on-premise requirement, TRUSTWORTHY configuration, Terms of Service
   - **Effort**: 2 hours

### P1: High Priority (Fix This Sprint)

4. **sql/ef-core/Hartonomous.Schema.sql Redundancy (8,136 Lines)**
   - **Problem**: Manual copy of EF migration output
   - **Impact**: Out-of-sync risk, manual maintenance burden
   - **Fix**: Delete file, use `dotnet ef migrations script` instead
   - **Effort**: 15 minutes

5. **3 BillingUsageLedger Implementations**
   - **Problem**: `BillingUsageLedger.sql`, `BillingUsageLedger_InMemory.sql`, `BillingUsageLedger_Migrate_to_Ledger.sql`
   - **Impact**: Unclear which implementation is current
   - **Fix**: Document migration path, archive old implementations
   - **Effort**: 1 day

6. **Duplicate CLR Function Definitions**
   - **Problem**: `clr_SemanticFeaturesJson` defined twice in same file
   - **Impact**: Deployment error
   - **Fix**: Remove duplicate
   - **Effort**: 15 minutes

### P2: Medium Priority (Fix Next Sprint)

7. **12 TODO/PLACEHOLDER/NOTE Comments**
   - **Problem**: Incomplete work scattered in SQL scripts
   - **Impact**: Potential runtime errors, incomplete features
   - **Fix**: Review each comment, implement or remove
   - **Effort**: 3 days

8. **No Automated Deployment Testing**
   - **Problem**: `deploy-database-unified.ps1` has no post-deployment test suite
   - **Impact**: Silent failures, schema corruption
   - **Fix**: Create comprehensive validation suite
   - **Effort**: 1 week

9. **Hardcoded Script Paths in Deployment**
   - **Problem**: Adding new SQL script requires updating PowerShell
   - **Impact**: Forgotten scripts, manual maintenance
   - **Fix**: Auto-discover scripts or use manifest file
   - **Effort**: 2 days

10. **Missing DbSets (11 Tables)**
    - **Problem**: Tables exist in SQL but not exposed via EF Core
    - **Impact**: Can't query via LINQ, ORM benefits lost
    - **Fix**: Add DbSets or document why excluded
    - **Effort**: 2 days

### P3: Low Priority (Technical Debt)

11. **Monolithic EF Core Migration**
    - **Problem**: Entire schema in one migration (2,000+ lines)
    - **Impact**: Difficult to review, no history
    - **Fix**: Document as technical debt (don't fix due to risk)
    - **Effort**: Documentation only (15 minutes)

12. **Native VECTOR/JSON Not Used**
    - **Problem**: Still using legacy `VARBINARY`/`nvarchar(max)` for vectors/JSON
    - **Impact**: Missing 50x performance improvement
    - **Fix**: Plan migration to native types (breaking change)
    - **Effort**: 2 weeks

---

## 8. Recommended Action Plan

### Phase 1: Clean Up Duplicates (Week 1)

**Goal**: Establish single source of truth for schema.

1. **Delete `sql/ef-core/Hartonomous.Schema.sql`** (8,136 lines)
   - Use `dotnet ef migrations script` instead
   - Add to `.gitignore` to prevent recreation

2. **Remove Duplicate Table Scripts** (15 files)
   - Delete: `dbo.Atoms.sql`, `dbo.AtomEmbeddings.sql`, `dbo.BillingUsageLedger.sql`, etc.
   - Keep only tables NOT in EF Core (11 legitimate manual tables)
   - Update `deploy-database-unified.ps1` to reflect changes

3. **Fix Duplicate CLR Function**
   - Remove duplicate `clr_SemanticFeaturesJson` definition
   - Verify all 40+ CLR functions are unique

4. **Document BillingUsageLedger Migration**
   - Archive `BillingUsageLedger_InMemory.sql` and `_Migrate_to_Ledger.sql`
   - Document current implementation (EF Core managed)

**Deliverables**:
- 16 files deleted
- Documentation updated (README.md, DEPLOYMENT.md)
- `deploy-database-unified.ps1` updated

### Phase 2: Documentation and Safety (Week 2)

**Goal**: Document security model, add deployment validation.

1. **Document UNSAFE CLR Requirements**
   - Add deployment prerequisites section (on-premise only, TRUSTWORTHY ON)
   - Document Terms of Service acceptance for autonomous features
   - Add security hardening recommendations (network isolation, SQL Server firewall)
   - Create troubleshooting guide for CLR permission errors

2. **Implement Missing CLR Function**
   - Add `clr_BytesToFloatArrayJson` to `SqlClrFunctions.dll`
   - Deploy and test

3. **Create Deployment Validation Suite** (`sql/verification/DeploymentTests.sql`)
   - Test CLR functions work (smoke tests)
   - Verify UNSAFE CLR assemblies are loaded
   - Verify indexes exist
   - Check temporal tables are enabled
   - Validate Service Broker queues
   - Test file system operations (read/write/execute permissions)

4. **Add Rollback Scripts**
   - Create rollback script for each deployment step
   - Test rollback in dev environment

**Deliverables**:
- UNSAFE CLR deployment guide with security hardening
- 1 missing function implemented
- Comprehensive validation suite (100+ tests including CLR permissions)
- Rollback automation

### Phase 3: Process Improvement (Week 3-4)

**Goal**: Mature deployment process to Level 3 (Defined).

1. **Auto-Discover SQL Scripts**
   - Replace hardcoded paths with pattern matching
   - Create script manifest file
   - Add validation to ensure all scripts are deployed

2. **CI/CD Integration**
   - Azure DevOps pipeline for database deployments
   - Automated testing on each commit
   - Schema drift detection (compare EF model to actual database)

3. **Deployment Metrics**
   - Track deployment duration
   - Log success/failure rate
   - Alert on schema drift

4. **Documentation Overhaul**
   - Update `DATABASE_DEPLOYMENT_GUIDE.md` with new process
   - Document which tables are EF Core vs manual SQL (architecture decision)
   - Add runbook for rollback scenarios

**Deliverables**:
- Automated deployment pipeline
- Schema drift detection
- Deployment metrics dashboard
- Comprehensive deployment documentation

### Phase 4: Performance Optimization (Backlog)

**Goal**: Migrate to SQL Server 2025 native types, add columnstore.

1. **Migrate to Native VECTOR Type**
   - Plan breaking change migration
   - Update EF Core configurations
   - Update CLR functions
   - Test performance (expect 50x improvement)

2. **Migrate to Native JSON Type**
   - Enable compatibility level 170
   - Generate migration (auto-converts `nvarchar(max)` → `json`)
   - Test JSON queries

3. **Add Columnstore to OLTP Tables**
   - `BillingUsageLedger` - NCCI on (CreatedAt, TenantId, OperationType)
   - `AutonomousImprovementHistory` - NCCI on (Timestamp, TenantId)

**Deliverables**:
- 50x vector operation performance improvement
- 20-30% faster JSON queries
- 40-60% better compression on ledger tables

---

## 9. Conclusion

**Current State**: Database deployment is **FRAGMENTED** across 109 SQL files, 1 monolithic EF Core migration, and a well-intentioned but incomplete deployment script.

**Root Cause**: "Half-assed AI agent work" that dumped everything into manual SQL scripts without considering:
- EF Core as source of truth for domain tables
- Manual SQL for advanced features (CLR, Service Broker, spatial)
- Deployment automation and testing
- Schema drift prevention

**Immediate Actions** (Week 1):
1. ✅ Delete `sql/ef-core/Hartonomous.Schema.sql` (8,136 line redundancy)
2. ✅ Remove 15 duplicate table scripts
3. ✅ Fix duplicate CLR function definition
4. ✅ Document BillingUsageLedger migration path

**Documentation Actions** (Week 2):
1. ✅ **DOCUMENT** UNSAFE CLR deployment prerequisites (on-premise requirement, security model)
2. ✅ Implement missing `clr_BytesToFloatArrayJson`
3. ✅ Create comprehensive deployment validation suite including CLR permission tests

**Process Improvements** (Week 3-4):
1. ✅ Auto-discover SQL scripts (eliminate hardcoded paths)
2. ✅ CI/CD integration for automated deployments
3. ✅ Schema drift detection
4. ✅ Deployment metrics and monitoring

**Future Optimization** (Backlog):
1. Migrate to SQL Server 2025 native VECTOR (50x performance)
2. Migrate to SQL Server 2025 native JSON (20-30% faster queries)
3. Add columnstore to OLTP tables (40-60% compression)

**Success Criteria**:
- **Single source of truth**: EF Core for domain tables, manual SQL for advanced features
- **Zero schema drift**: Automated detection and alerts
- **Automated deployments**: CI/CD pipeline with comprehensive testing
- **Security documentation**: UNSAFE CLR requirements clearly documented with deployment prerequisites
- **Performance**: Native VECTOR/JSON types enabled

The database deployment is **recoverable** but needs focused cleanup effort to eliminate duplication, security risks, and deployment fragmentation. The deployment script foundation is solid - it just needs cleanup of the underlying SQL assets and better automation/testing.

---

**Next Steps**: Execute Phase 1 cleanup (Week 1), then create deployment validation suite (Week 2).