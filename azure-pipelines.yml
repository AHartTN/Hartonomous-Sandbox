# ============================================================================
# Hartonomous Azure DevOps Pipeline
# Complete CI/CD for SQL Server Database + CLR + .NET 10 Applications
# Based on Microsoft Docs 2024/2025 Official Guidance
# ============================================================================
#
# Usage:
#   - Automatic: Triggers on main branch push
#   - Manual: Can override sqlServer/sqlDatabase parameters via pipeline UI
#
# Environments:
#   - localhost: Local development (Windows Auth)
#   - development: Dev server (Azure AD or Windows Auth)
#   - staging: Staging server (Azure AD)
#   - production: Production server (Azure AD + Arc)
# ============================================================================

name: Hartonomous-$(Date:yyyyMMdd)$(Rev:.r)

trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - docs/**
      - '*.md'
      - LICENSE

# Pipeline parameters - can be overridden at queue time
parameters:
  - name: environment
    displayName: 'Target Environment'
    type: string
    default: 'development'
    values:
      - localhost
      - development
      - staging
      - production

  - name: sqlServer
    displayName: 'SQL Server Instance'
    type: string
    default: 'localhost'

  - name: sqlDatabase
    displayName: 'Database Name'
    type: string
    default: 'Hartonomous'

  - name: agentPool
    displayName: 'Agent Pool'
    type: string
    default: 'Local Agent Pool'

pool:
  name: ${{ parameters.agentPool }}

variables:
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetSdkVersion
    value: '10.x'
  - name: sqlServer
    value: ${{ parameters.sqlServer }}
  - name: sqlDatabase
    value: ${{ parameters.sqlDatabase }}
  - name: targetEnvironment
    value: ${{ parameters.environment }}

stages:
# ============================================================================
# STAGE 1: BUILD DATABASE DACPAC ONLY
# ============================================================================
- stage: BuildDatabase
  displayName: 'Build Database DACPAC'
  jobs:
  - job: BuildDACPAC
    displayName: 'Build Database DACPAC'
    steps:
    # Install .NET 10 SDK
    - task: UseDotNet@2
      displayName: 'Install .NET 10 SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetSdkVersion)'
        performMultiLevelLookup: true
    
    # Initialize CLR Signing Certificate (idempotent)
    - task: PowerShell@2
      displayName: 'Initialize CLR Signing Certificate'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/Initialize-CLRSigning.ps1'
        pwsh: true
      continueOnError: false
    
    # Build DACPAC using msbuild (agent must have MSBuild or Visual Studio)
    - task: PowerShell@2
      displayName: 'Build SQL Database Project with MSBuild'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/build-dacpac.ps1'
        arguments: '-ProjectPath "src/Hartonomous.Database/Hartonomous.Database.sqlproj" -OutputDir "$(Build.ArtifactStagingDirectory)/database/" -Configuration $(buildConfiguration)'
        pwsh: true
    
    # Sign CLR Assemblies (auto-discovers DLLs, filters Microsoft assemblies)
    - task: PowerShell@2
      displayName: 'Sign CLR Assemblies'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/Sign-CLRAssemblies.ps1'
        arguments: '-Configuration $(buildConfiguration) -Verbose'
        pwsh: true
      continueOnError: false
        
    # Verify DACPAC
    - task: PowerShell@2
      displayName: 'Verify DACPAC Build'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/verify-dacpac.ps1'
        arguments: '-DacpacPath "$(Build.ArtifactStagingDirectory)/database/Hartonomous.Database.dacpac"'
        pwsh: true

    # Copy external CLR dependencies
    - task: CopyFiles@2
      displayName: 'Copy External CLR Dependencies'
      inputs:
        SourceFolder: 'dependencies'
        Contents: '*.dll'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/database/dependencies'

    # Copy deployment scripts
    - task: CopyFiles@2
      displayName: 'Copy Deployment Scripts'
      inputs:
        SourceFolder: 'scripts'
        Contents: '*.ps1'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/database/scripts'

    # Publish database artifacts
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Database Artifacts'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/database'
        artifact: 'database'
        publishLocation: 'pipeline'

# ============================================================================
# STAGE 2: DEPLOY DATABASE (DACPAC + EXTERNAL CLR)
# ============================================================================
- stage: DeployDatabase
  displayName: 'Deploy Database Schema'
  dependsOn: BuildDatabase
  condition: succeeded()
  jobs:
  - deployment: DatabaseDeployment
    displayName: 'Deploy to SQL Server'
    pool:
      name: 'Local Agent Pool'
    environment: 'SQL-Server-Production'
    strategy:
      runOnce:
        deploy:
          steps:
          # Download database artifact
          - download: current
            artifact: database

          # Step 0: Deploy CLR Signing Certificate to SQL Server (Production Mode)
          - task: PowerShell@2
            displayName: 'Deploy CLR Signing Certificate to SQL Server'
            inputs:
              targetType: 'filePath'
              filePath: '$(Pipeline.Workspace)/database/scripts/Deploy-CLRCertificate.ps1'
              arguments: '-Server "$(sqlServer)" -Database "$(sqlDatabase)" -EnableStrictSecurity $true'
              pwsh: true
            continueOnError: false

          # Step 1: Grant Pipeline Agent Permissions (Idempotent)
          - task: PowerShell@2
            displayName: 'Grant Agent Permissions (Integrated Windows Auth)'
            inputs:
              targetType: 'filePath'
              filePath: '$(Pipeline.Workspace)/database/scripts/grant-agent-permissions.ps1'
              arguments: '-Server "$(sqlServer)"'
              pwsh: true

          # Step 2: Enable CLR Integration (Idempotent)
          - task: PowerShell@2
            displayName: 'Enable CLR Integration (Integrated Windows Auth)'
            inputs:
              targetType: 'filePath'
              filePath: '$(Pipeline.Workspace)/database/scripts/enable-clr.ps1'
              arguments: '-Server "$(sqlServer)"'
              pwsh: true

          # Step 3: Deploy External CLR Assemblies
          - task: PowerShell@2
            displayName: 'Deploy External CLR Assemblies (Integrated Windows Auth)'
            inputs:
              targetType: 'filePath'
              filePath: '$(Pipeline.Workspace)/database/scripts/deploy-clr-assemblies.ps1'
              arguments: '-Server "$(sqlServer)" -Database "$(sqlDatabase)" -DependenciesPath "$(Pipeline.Workspace)/database/dependencies"'
              pwsh: true

          # Step 4: Deploy DACPAC (includes Hartonomous.Clr.dll)
          - task: PowerShell@2
            displayName: 'Install SqlPackage'
            inputs:
              targetType: 'filePath'
              filePath: '$(Pipeline.Workspace)/database/scripts/install-sqlpackage.ps1'
              pwsh: true
              
          - task: PowerShell@2
            displayName: 'Deploy DACPAC with Hartonomous.Clr Assembly (Integrated Windows Auth)'
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = 'Stop'
                
                $dacpacPath = "$(Pipeline.Workspace)/database/Hartonomous.Database.dacpac"
                $connectionString = "Server=$(sqlServer);Database=$(sqlDatabase);Integrated Security=True;Encrypt=True;TrustServerCertificate=True;"
                
                Write-Host "Deploying DACPAC: $dacpacPath"
                Write-Host "Target: $(sqlServer)/$(sqlDatabase)"
                Write-Host "Authentication: Integrated Windows Authentication (Network Service)"
                Write-Host "This DACPAC includes Hartonomous.Clr.dll assembly embedded as hex binary"
                
                # Deploy using SqlPackage with Windows integrated auth
                # Post-deployment scripts include Service Broker activation
                sqlpackage /Action:Publish `
                  /SourceFile:"$dacpacPath" `
                  /TargetConnectionString:"$connectionString" `
                  /p:DropObjectsNotInSource=False `
                  /p:BlockOnPossibleDataLoss=True
                
                if ($LASTEXITCODE -ne 0) { throw "DACPAC deployment failed" }
                Write-Host "✓ DACPAC deployed successfully with Hartonomous.Clr assembly"
                Write-Host "✓ Post-deployment scripts executed (Service Broker activation, CLR dependencies)"
              pwsh: true

          # Step 5: Verify CLR Assembly Signatures and Security (Production Validation)
          - task: PowerShell@2
            displayName: 'Verify CLR Assembly Signatures and Security'
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = 'Stop'
                
                Write-Host "Verifying CLR assembly signatures and security configuration..."
                
                # Query to verify signatures and CLR Strict Security
                $query = @"
                -- Check CLR Strict Security (should be 1 in production)
                SELECT name, CAST(value AS int) AS value, CAST(value_in_use AS int) AS value_in_use
                FROM sys.configurations 
                WHERE name = 'clr strict security';
                
                -- Check all assemblies and their signatures
                SELECT 
                  a.name AS AssemblyName,
                  CASE a.permission_set 
                    WHEN 1 THEN 'SAFE'
                    WHEN 2 THEN 'EXTERNAL_ACCESS'
                    WHEN 3 THEN 'UNSAFE_ACCESS'
                  END AS PermissionSet,
                  CASE 
                    WHEN c.name IS NOT NULL THEN 'SIGNED (via Certificate)'
                    WHEN ak.name IS NOT NULL THEN 'SIGNED (via Asymmetric Key)'
                    ELSE 'UNSIGNED'
                  END AS SignatureStatus,
                  c.name AS CertificateName,
                  ak.name AS AsymmetricKeyName
                FROM sys.assemblies a
                LEFT JOIN sys.assembly_files af ON a.assembly_id = af.assembly_id
                LEFT JOIN sys.certificates c ON c.thumbprint = af.content
                LEFT JOIN sys.asymmetric_keys ak ON ak.thumbprint = af.content
                WHERE a.name NOT IN ('master', 'model', 'msdb', 'tempdb')
                ORDER BY a.name;
                "@
                
                $result = sqlcmd -S "$(sqlServer)" -d "$(sqlDatabase)" -E -Q $query -W -s "," -h -1
                
                Write-Host "`n=== CLR Security Verification Results ==="
                Write-Host $result
                
                # Check for unsigned assemblies (fail if any found in production)
                if ($result -match 'UNSIGNED') {
                  Write-Host "`n❌ ERROR: Unsigned assemblies detected in production mode!"
                  Write-Host "All assemblies must be signed for ISO-certification compliance."
                  exit 1
                }
                
                # Check CLR Strict Security is enabled
                if ($result -match 'clr strict security.*,0,') {
                  Write-Host "`n⚠️ WARNING: CLR Strict Security is DISABLED!"
                  Write-Host "Enabling CLR Strict Security for production..."
                  sqlcmd -S "$(sqlServer)" -d "$(sqlDatabase)" -E -Q "EXEC sp_configure 'clr strict security', 1; RECONFIGURE;"
                }
                
                Write-Host "`n✓ CLR security verification complete - all assemblies signed"
              pwsh: true

          # Step 6: Set TRUSTWORTHY ON (Idempotent - only if needed for legacy compatibility)
          - task: PowerShell@2
            displayName: 'Set TRUSTWORTHY ON (Integrated Windows Auth)'
            inputs:
              targetType: 'filePath'
              filePath: '$(Pipeline.Workspace)/database/scripts/set-trustworthy.ps1'
              arguments: '-Server "$(sqlServer)" -Database "$(sqlDatabase)"'
              pwsh: true

# ============================================================================
# STAGE 3: SCAFFOLD EF CORE ENTITIES
# ============================================================================
- stage: ScaffoldEntities
  displayName: 'Scaffold EF Core Entities'
  dependsOn: DeployDatabase
  condition: succeeded()
  jobs:
  - job: Scaffold
    displayName: 'Generate Entity Classes from DB'
    pool:
      name: 'Local Agent Pool'
    steps:
    # Install .NET 10 SDK
    - task: UseDotNet@2
      displayName: 'Install .NET 10 SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetSdkVersion)'
    
    # Scaffold entities from deployed database using Windows integrated auth
    - task: PowerShell@2
      displayName: 'Scaffold EF Core Entities (Integrated Windows Auth)'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/scaffold-entities.ps1'
        arguments: '-Server "$(sqlServer)" -Database "$(sqlDatabase)"'
        pwsh: true
    
    # Publish scaffolded entities as pipeline artifact
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Scaffolded Entities'
      inputs:
        targetPath: 'src/Hartonomous.Data.Entities'
        artifact: 'entities'
        publishLocation: 'pipeline'

# ============================================================================
# STAGE 4: BUILD .NET SOLUTION
# ============================================================================
- stage: BuildDotNet
  displayName: 'Build .NET Solution'
  dependsOn: ScaffoldEntities
  condition: succeeded()
  jobs:
  - job: BuildDotNetJob
    displayName: 'Build .NET Solution + CLR'
    pool:
      name: 'Local Agent Pool'
    steps:
    # Download scaffolded entities from previous stage
    - download: current
      artifact: entities
      displayName: 'Download Scaffolded Entities'
    
    # Copy scaffolded entities to source directory
    - task: PowerShell@2
      displayName: 'Copy Scaffolded Entities to Source'
      inputs:
        targetType: 'inline'
        script: |
          $source = "$(Pipeline.Workspace)/entities"
          $dest = "src/Hartonomous.Data.Entities"
          
          if (Test-Path $dest) {
            Remove-Item -Recurse -Force $dest
          }
          
          Copy-Item -Recurse -Force $source $dest
          Write-Host "✓ Scaffolded entities copied to $dest"
        pwsh: true
    
    # Install .NET 10 SDK
    - task: UseDotNet@2
      displayName: 'Install .NET 10 SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetSdkVersion)'

    # Restore NuGet packages
    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet Packages'
      inputs:
        command: 'restore'
        projects: 'Hartonomous.sln'
        feedsToUse: 'select'

    # Build solution
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution (Release)'
      inputs:
        command: 'build'
        projects: 'Hartonomous.sln'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    # Run unit tests
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests (Hybrid Database Testing)'
      inputs:
        command: 'test'
        projects: 'tests/**/*Tests.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --logger trx'
        publishTestResults: true
      env:
        # DatabaseTestBase auto-detects environment:
        # - Windows agent without CI var → LocalDB (fast)
        # - Linux agent with CI var → Docker (consistent)
        # - Staging/Prod → Azure SQL (via connection string)
        CI: $(Build.BuildId)  # Presence of CI var triggers CI mode

    # Publish applications
    - task: DotNetCoreCLI@2
      displayName: 'Publish Hartonomous.Api'
      inputs:
        command: 'publish'
        projects: 'src/Hartonomous.Api/Hartonomous.Api.csproj'
        publishWebProjects: false
        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/api'
        zipAfterPublish: false

    - task: DotNetCoreCLI@2
      displayName: 'Publish CesConsumer'
      inputs:
        command: 'publish'
        projects: 'src/Hartonomous.Workers.CesConsumer/Hartonomous.Workers.CesConsumer.csproj'
        publishWebProjects: false
        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/ces-consumer'
        zipAfterPublish: false

    - task: DotNetCoreCLI@2
      displayName: 'Publish Neo4jSync'
      inputs:
        command: 'publish'
        projects: 'src/Hartonomous.Workers.Neo4jSync/Hartonomous.Workers.Neo4jSync.csproj'
        publishWebProjects: false
        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/neo4j-sync'
        zipAfterPublish: false

    # Copy deployment scripts
    - task: CopyFiles@2
      displayName: 'Copy Deployment Scripts'
      inputs:
        SourceFolder: 'scripts'
        Contents: '**'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/scripts'

    # Copy procedure files
    - task: CopyFiles@2
      displayName: 'Copy Stored Procedures'
      inputs:
        SourceFolder: 'src/Hartonomous.Database/Procedures'
        Contents: '**/*.sql'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/database/Procedures'

    # Publish .NET artifacts
    - task: PublishPipelineArtifact@1
      displayName: 'Publish .NET Artifacts'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifact: 'dotnet'
        publishLocation: 'pipeline'

# ============================================================================
# STAGE 5: DEPLOY APPLICATIONS (Optional)
# ============================================================================
- stage: DeployApplications
  displayName: 'Deploy .NET Applications'
  dependsOn: BuildDotNet
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: AppDeployment
    displayName: 'Deploy Applications'
    pool:
      vmImage: 'windows-latest'
    environment: 'Application-Servers'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: dotnet

          - task: PowerShell@2
            displayName: 'Display Deployment Summary'
            inputs:
              targetType: 'filePath'
              filePath: '$(Pipeline.Workspace)/dotnet/scripts/deployment-summary.ps1'
              arguments: '-Server "$(sqlServer)" -Database "$(sqlDatabase)" -ArtifactPath "$(Pipeline.Workspace)/dotnet"'
              pwsh: true
