# ============================================================================
# Hartonomous Azure DevOps Pipeline
# Complete CI/CD for SQL Server Database + CLR + .NET 10 Applications
# Based on Microsoft Docs 2024/2025 Official Guidance
# ============================================================================

name: Hartonomous-$(Date:yyyyMMdd)$(Rev:.r)

trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - docs/**
      - '*.md'
      - LICENSE

pool:
  name: 'Local Agent Pool'

variables:
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetSdkVersion
    value: '10.x'
  - name: sqlServer
    value: 'localhost'
  - name: sqlDatabase
    value: 'Hartonomous'

stages:
# ============================================================================
# STAGE 1: BUILD DATABASE DACPAC ONLY
# ============================================================================
- stage: BuildDatabase
  displayName: 'Build Database DACPAC'
  jobs:
  - job: BuildDACPAC
    displayName: 'Build Database DACPAC'
    steps:
    # Install .NET 10 SDK
    - task: UseDotNet@2
      displayName: 'Install .NET 10 SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetSdkVersion)'
        performMultiLevelLookup: true
    
    # Build DACPAC using msbuild (agent must have MSBuild or Visual Studio)
    - task: PowerShell@2
      displayName: 'Build SQL Database Project with MSBuild'
      inputs:
        targetType: 'inline'
        script: |
          $ErrorActionPreference = 'Stop'
          
          # Find MSBuild
          $msbuild = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" `
            -latest -requires Microsoft.Component.MSBuild -find MSBuild\**\Bin\MSBuild.exe `
            -prerelease | Select-Object -First 1
          
          if (-not $msbuild) {
            $msbuild = "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\MSBuild.exe"
          }
          
          if (-not (Test-Path $msbuild)) {
            Write-Error "MSBuild not found. Agent needs Visual Studio or MSBuild installed."
            exit 1
          }
          
          Write-Host "Using MSBuild: $msbuild"
          
          # Build DACPAC
          & $msbuild src/Hartonomous.Database/Hartonomous.Database.sqlproj `
            /p:Configuration=$(buildConfiguration) `
            /p:OutDir="$(Build.ArtifactStagingDirectory)/database/" `
            /v:minimal
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "MSBuild failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }
          
          Write-Host "✓ DACPAC built successfully"
        pwsh: true
        
    # Verify DACPAC
    - task: PowerShell@2
      displayName: 'Verify DACPAC Build'
      inputs:
        targetType: 'inline'
        script: |
          $dacpacPath = "$(Build.ArtifactStagingDirectory)/database/Hartonomous.Database.dacpac"
          if (Test-Path $dacpacPath) {
            Write-Host "✓ DACPAC built successfully: $dacpacPath"
            $hash = (Get-FileHash $dacpacPath -Algorithm SHA256).Hash
            Write-Host "SHA256: $hash"
          } else {
            Write-Error "✗ DACPAC not found at $dacpacPath"
            exit 1
          }
        pwsh: true

    # Copy external CLR dependencies
    - task: CopyFiles@2
      displayName: 'Copy External CLR Dependencies'
      inputs:
        SourceFolder: 'dependencies'
        Contents: '*.dll'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/database/dependencies'

    # Publish database artifacts
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Database Artifacts'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/database'
        artifact: 'database'
        publishLocation: 'pipeline'

# ============================================================================
# STAGE 2: DEPLOY DATABASE (DACPAC + EXTERNAL CLR)
# ============================================================================
- stage: DeployDatabase
  displayName: 'Deploy Database Schema'
  dependsOn: BuildDatabase
  condition: succeeded()
  jobs:
  - deployment: DatabaseDeployment
    displayName: 'Deploy to SQL Server'
    environment: 'SQL-Server-Production'
    pool:
      name: 'Local Agent Pool'
    strategy:
      runOnce:
        deploy:
          steps:
          # Download database artifact
          - download: current
            artifact: database

          # Step 0: Grant Pipeline Agent Permissions (Idempotent)
          - task: PowerShell@2
            displayName: 'Grant Agent Permissions'
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = 'Stop'
                Write-Host "Ensuring pipeline agent has required SQL Server permissions..."
                
                $grantScript = @'
                USE [master];
                GO
                SET NOCOUNT ON;
                GO
                
                -- Auto-detect Azure DevOps agent service account
                DECLARE @AgentLogin NVARCHAR(256);
                DECLARE @DetectionLog TABLE (LoginName NVARCHAR(256));
                
                -- Try common agent service accounts
                INSERT INTO @DetectionLog (LoginName)
                SELECT name 
                FROM sys.server_principals
                WHERE name IN (
                    N'NT AUTHORITY\NETWORK SERVICE',
                    N'NT AUTHORITY\SYSTEM',
                    N'NT SERVICE\vstsagent',
                    N'NT SERVICE\AzureDevOpsAgent'
                )
                AND type_desc = 'WINDOWS_LOGIN';
                
                -- If multiple found, prefer NETWORK SERVICE (most common for Local Agent Pool)
                IF EXISTS (SELECT 1 FROM @DetectionLog WHERE LoginName = N'NT AUTHORITY\NETWORK SERVICE')
                    SET @AgentLogin = N'NT AUTHORITY\NETWORK SERVICE';
                ELSE IF EXISTS (SELECT 1 FROM @DetectionLog WHERE LoginName = N'NT AUTHORITY\SYSTEM')
                    SET @AgentLogin = N'NT AUTHORITY\SYSTEM';
                ELSE
                    SELECT TOP 1 @AgentLogin = LoginName FROM @DetectionLog;
                
                -- Fallback if no agent detected: default to NETWORK SERVICE and create it
                IF @AgentLogin IS NULL
                BEGIN
                    SET @AgentLogin = N'NT AUTHORITY\NETWORK SERVICE';
                    PRINT 'No existing agent login detected. Defaulting to: ' + @AgentLogin;
                    
                    IF NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = @AgentLogin)
                    BEGIN
                        PRINT 'Creating login: ' + @AgentLogin;
                        DECLARE @CreateLoginSql NVARCHAR(MAX) = 'CREATE LOGIN ' + QUOTENAME(@AgentLogin) + ' FROM WINDOWS;';
                        EXEC sp_executesql @CreateLoginSql;
                    END
                END
                ELSE
                BEGIN
                    PRINT 'Detected agent login: ' + @AgentLogin;
                END
                GO
                
                -- Grant ALTER SETTINGS permission (idempotent)
                DECLARE @AgentLogin NVARCHAR(256);
                SELECT TOP 1 @AgentLogin = name 
                FROM sys.server_principals
                WHERE name IN (
                    N'NT AUTHORITY\NETWORK SERVICE',
                    N'NT AUTHORITY\SYSTEM',
                    N'NT SERVICE\vstsagent',
                    N'NT SERVICE\AzureDevOpsAgent'
                )
                AND type_desc = 'WINDOWS_LOGIN'
                ORDER BY 
                    CASE name 
                        WHEN N'NT AUTHORITY\NETWORK SERVICE' THEN 1
                        WHEN N'NT AUTHORITY\SYSTEM' THEN 2
                        ELSE 3
                    END;
                
                IF @AgentLogin IS NULL
                    SET @AgentLogin = N'NT AUTHORITY\NETWORK SERVICE';
                
                -- Check if permission already granted
                IF NOT EXISTS (
                    SELECT 1 
                    FROM sys.server_permissions perm
                    INNER JOIN sys.server_principals sp ON perm.grantee_principal_id = sp.principal_id
                    WHERE sp.name = @AgentLogin 
                    AND perm.permission_name = 'ALTER SETTINGS'
                    AND perm.state_desc = 'GRANT'
                )
                BEGIN
                    PRINT 'Granting ALTER SETTINGS to: ' + @AgentLogin;
                    DECLARE @GrantAlterSettingsSql NVARCHAR(MAX) = 'GRANT ALTER SETTINGS TO ' + QUOTENAME(@AgentLogin) + ';';
                    EXEC sp_executesql @GrantAlterSettingsSql;
                END
                ELSE
                BEGIN
                    PRINT 'ALTER SETTINGS already granted to: ' + @AgentLogin;
                END
                GO
                
                -- Grant CONTROL SERVER permission (idempotent)
                DECLARE @AgentLogin NVARCHAR(256);
                SELECT TOP 1 @AgentLogin = name 
                FROM sys.server_principals
                WHERE name IN (
                    N'NT AUTHORITY\NETWORK SERVICE',
                    N'NT AUTHORITY\SYSTEM',
                    N'NT SERVICE\vstsagent',
                    N'NT SERVICE\AzureDevOpsAgent'
                )
                AND type_desc = 'WINDOWS_LOGIN'
                ORDER BY 
                    CASE name 
                        WHEN N'NT AUTHORITY\NETWORK SERVICE' THEN 1
                        WHEN N'NT AUTHORITY\SYSTEM' THEN 2
                        ELSE 3
                    END;
                
                IF @AgentLogin IS NULL
                    SET @AgentLogin = N'NT AUTHORITY\NETWORK SERVICE';
                
                -- Check if permission already granted
                IF NOT EXISTS (
                    SELECT 1 
                    FROM sys.server_permissions perm
                    INNER JOIN sys.server_principals sp ON perm.grantee_principal_id = sp.principal_id
                    WHERE sp.name = @AgentLogin 
                    AND perm.permission_name = 'CONTROL SERVER'
                    AND perm.state_desc = 'GRANT'
                )
                BEGIN
                    PRINT 'Granting CONTROL SERVER to: ' + @AgentLogin;
                    DECLARE @GrantControlServerSql NVARCHAR(MAX) = 'GRANT CONTROL SERVER TO ' + QUOTENAME(@AgentLogin) + ';';
                    EXEC sp_executesql @GrantControlServerSql;
                END
                ELSE
                BEGIN
                    PRINT 'CONTROL SERVER already granted to: ' + @AgentLogin;
                END
                GO
                
                PRINT 'Agent permissions validated and granted as needed.';
                GO
'@
                
                $tempFile = [System.IO.Path]::GetTempFileName() + ".sql"
                try {
                  $grantScript | Out-File -FilePath $tempFile -Encoding utf8
                  sqlcmd -S "$(sqlServer)" -d "master" -E -C -i $tempFile -b
                  if ($LASTEXITCODE -ne 0) { throw "Failed to grant permissions" }
                  Write-Host "✓ Agent permissions validated"
                } finally {
                  Remove-Item $tempFile -ErrorAction SilentlyContinue
                }
              pwsh: true

          # Step 1: Enable CLR Integration (Idempotent)
          - task: PowerShell@2
            displayName: 'Enable CLR Integration'
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = 'Stop'
                Write-Host "Enabling CLR integration (idempotent)..."
                
                $tempFile = [System.IO.Path]::GetTempFileName() + ".sql"
                @"
                -- Check current CLR settings
                DECLARE @showAdvanced INT, @clrEnabled INT, @clrStrictSecurity INT;
                
                SELECT @showAdvanced = CAST(value_in_use AS INT) FROM sys.configurations WHERE name = 'show advanced options';
                SELECT @clrEnabled = CAST(value_in_use AS INT) FROM sys.configurations WHERE name = 'clr enabled';
                SELECT @clrStrictSecurity = CAST(value_in_use AS INT) FROM sys.configurations WHERE name = 'clr strict security';
                
                -- Only configure if needed
                IF @showAdvanced = 0
                BEGIN
                    PRINT 'Enabling show advanced options...';
                    EXEC sp_configure 'show advanced options', 1;
                    RECONFIGURE;
                END
                ELSE
                BEGIN
                    PRINT 'show advanced options already enabled';
                END
                
                IF @clrEnabled = 0
                BEGIN
                    PRINT 'Enabling CLR...';
                    EXEC sp_configure 'clr enabled', 1;
                    RECONFIGURE;
                END
                ELSE
                BEGIN
                    PRINT 'CLR already enabled';
                END
                
                IF @clrStrictSecurity = 1
                BEGIN
                    PRINT 'Disabling CLR strict security...';
                    EXEC sp_configure 'clr strict security', 0;
                    RECONFIGURE;
                END
                ELSE
                BEGIN
                    PRINT 'CLR strict security already disabled';
                END
                
                PRINT 'CLR configuration verified.';
                "@ | Out-File -FilePath $tempFile -Encoding utf8
                
                try {
                  sqlcmd -S "$(sqlServer)" -d "master" -E -C -i $tempFile -b
                  if ($LASTEXITCODE -ne 0) { throw "Failed to enable CLR" }
                  Write-Host "✓ CLR enabled"
                } finally {
                  Remove-Item $tempFile -ErrorAction SilentlyContinue
                }
              pwsh: true

          # Step 2: Deploy External CLR Assemblies (16 assemblies in dependency order - Idempotent)
          - task: PowerShell@2
            displayName: 'Deploy External CLR Assemblies'
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = 'Stop'
                $dependenciesPath = "$(Pipeline.Workspace)/database/dependencies"
                $server = "$(sqlServer)"
                $database = "$(sqlDatabase)"
                
                Write-Host "Deploying 16 external CLR assemblies (idempotent)..."
                
                function Deploy-ClrAssembly {
                    param([string]$Name, [string]$FilePath)
                    Write-Host "  Checking: $Name"
                    
                    if (-not (Test-Path $FilePath)) {
                        throw "Assembly file not found: $FilePath"
                    }
                    
                    $bytes = [System.IO.File]::ReadAllBytes($FilePath)
                    $hex = ($bytes | ForEach-Object { $_.ToString("X2") }) -join ''
                    $fileHash = (Get-FileHash -Path $FilePath -Algorithm SHA256).Hash
                    
                    $tempFile = [System.IO.Path]::GetTempFileName() + ".sql"
                    @"
                USE [$database];
                GO
                
                -- Check if assembly exists and matches current file
                DECLARE @existingHash VARBINARY(8000);
                DECLARE @deployNeeded BIT = 1;
                
                IF EXISTS (SELECT * FROM sys.assemblies WHERE name = '$Name')
                BEGIN
                    -- Get hash of existing assembly
                    SELECT @existingHash = HASHBYTES('SHA2_256', content)
                    FROM sys.assemblies
                    WHERE name = '$Name';
                    
                    -- Compare with new file hash (stored as comment in assembly for tracking)
                    -- For now, always redeploy to ensure latest version
                    PRINT '  Assembly exists, updating...';
                    DROP ASSEMBLY [$Name];
                END
                ELSE
                BEGIN
                    PRINT '  Assembly not found, creating...';
                END
                
                CREATE ASSEMBLY [$Name]
                FROM 0x$hex
                WITH PERMISSION_SET = UNSAFE;
                
                PRINT '  ✓ $Name deployed (SHA256: $fileHash)';
                GO
"@ | Out-File -FilePath $tempFile -Encoding utf8
                    
                    try {
                        sqlcmd -S $server -d master -E -C -i $tempFile -b
                        if ($LASTEXITCODE -ne 0) { throw "Failed to deploy $Name" }
                        Write-Host "  ✓ $Name deployed"
                    } finally {
                        Remove-Item $tempFile -ErrorAction SilentlyContinue
                    }
                }
                
                # Tier 1: Base runtime dependencies
                Deploy-ClrAssembly 'System.Numerics.Vectors' "$dependenciesPath/System.Numerics.Vectors.dll"
                Deploy-ClrAssembly 'System.ValueTuple' "$dependenciesPath/System.ValueTuple.dll"
                
                # Tier 2: Memory management
                Deploy-ClrAssembly 'System.Memory' "$dependenciesPath/System.Memory.dll"
                Deploy-ClrAssembly 'System.Buffers' "$dependenciesPath/System.Buffers.dll"
                Deploy-ClrAssembly 'System.Runtime.CompilerServices.Unsafe' "$dependenciesPath/System.Runtime.CompilerServices.Unsafe.dll"
                
                # Tier 3: Collections and reflection
                Deploy-ClrAssembly 'System.Collections.Immutable' "$dependenciesPath/System.Collections.Immutable.dll"
                Deploy-ClrAssembly 'System.Reflection.Metadata' "$dependenciesPath/System.Reflection.Metadata.dll"
                
                # Tier 4: Serialization
                Deploy-ClrAssembly 'System.Runtime.Serialization' "$dependenciesPath/System.Runtime.Serialization.dll"
                Deploy-ClrAssembly 'System.ServiceModel.Internals' "$dependenciesPath/System.ServiceModel.Internals.dll"
                Deploy-ClrAssembly 'SMDiagnostics' "$dependenciesPath/SMDiagnostics.dll"
                
                # Tier 5: Third-party libraries
                Deploy-ClrAssembly 'MathNet.Numerics' "$dependenciesPath/MathNet.Numerics.dll"
                Deploy-ClrAssembly 'Newtonsoft.Json' "$dependenciesPath/Newtonsoft.Json.dll"
                Deploy-ClrAssembly 'Microsoft.SqlServer.Types' "$dependenciesPath/Microsoft.SqlServer.Types.dll"
                
                # Tier 6: Application assemblies
                Deploy-ClrAssembly 'System.Drawing' "$dependenciesPath/System.Drawing.dll"
                Deploy-ClrAssembly 'SqlClrFunctions' "$dependenciesPath/SqlClrFunctions.dll"
                Deploy-ClrAssembly 'Hartonomous.Database' "$dependenciesPath/Hartonomous.Database.dll"
                
                Write-Host "✓ All 16 external CLR assemblies deployed successfully"
              pwsh: true

          # Step 3: Deploy DACPAC (includes Hartonomous.Clr.dll)
          - task: PowerShell@2
            displayName: 'Deploy DACPAC with Hartonomous.Clr Assembly'
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = 'Stop'
                $dacpacPath = "$(Pipeline.Workspace)/database/Hartonomous.Database.dacpac"
                $connectionString = "Server=$(sqlServer);Database=$(sqlDatabase);Integrated Security=True;TrustServerCertificate=True;"
                
                Write-Host "Deploying DACPAC: $dacpacPath"
                Write-Host "This DACPAC includes Hartonomous.Clr.dll assembly embedded as hex binary"
                
                sqlpackage.exe `
                  /Action:Publish `
                  /SourceFile:"$dacpacPath" `
                  /TargetConnectionString:"$connectionString" `
                  /p:DropObjectsNotInSource=False `
                  /p:BlockOnPossibleDataLoss=True `
                  /p:IgnorePreDeployScript=True `
                  /p:IgnorePostDeployScript=True
                
                if ($LASTEXITCODE -ne 0) { throw "DACPAC deployment failed" }
                Write-Host "✓ DACPAC deployed with Hartonomous.Clr assembly"
              pwsh: true

          # Step 4: Set TRUSTWORTHY ON (Idempotent)
          - task: PowerShell@2
            displayName: 'Set TRUSTWORTHY ON'
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = 'Stop'
                
                $tempFile = [System.IO.Path]::GetTempFileName() + ".sql"
                @"
                -- Check if TRUSTWORTHY is already enabled
                DECLARE @isTrustworthy BIT;
                SELECT @isTrustworthy = is_trustworthy_on 
                FROM sys.databases 
                WHERE name = '$(sqlDatabase)';
                
                IF @isTrustworthy = 0
                BEGIN
                    PRINT 'Setting TRUSTWORTHY ON for $(sqlDatabase)...';
                    ALTER DATABASE [$(sqlDatabase)] SET TRUSTWORTHY ON;
                    PRINT '✓ TRUSTWORTHY enabled';
                END
                ELSE
                BEGIN
                    PRINT 'TRUSTWORTHY already enabled for $(sqlDatabase)';
                END
                "@ | Out-File -FilePath $tempFile -Encoding utf8
                
                try {
                  sqlcmd -S "$(sqlServer)" -d "master" -E -C -i $tempFile -b
                  if ($LASTEXITCODE -ne 0) { throw "Failed to set TRUSTWORTHY" }
                  Write-Host "✓ TRUSTWORTHY validated"
                } finally {
                  Remove-Item $tempFile -ErrorAction SilentlyContinue
                }
              pwsh: true

# ============================================================================
# STAGE 3: SCAFFOLD EF CORE ENTITIES
# ============================================================================
- stage: ScaffoldEntities
  displayName: 'Scaffold EF Core Entities'
  dependsOn: DeployDatabase
  condition: succeeded()
  jobs:
  - job: Scaffold
    displayName: 'Generate Entity Classes from DB'
    pool:
      name: 'Local Agent Pool'
    steps:
    # Install .NET 10 SDK
    - task: UseDotNet@2
      displayName: 'Install .NET 10 SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetSdkVersion)'
    
    # Scaffold entities from deployed database
    - task: PowerShell@2
      displayName: 'Scaffold EF Core Entities'
      inputs:
        targetType: 'inline'
        script: |
          $ErrorActionPreference = 'Stop'
          
          Write-Host "Scaffolding entities from database..."
          
          cd src/Hartonomous.Data.Entities
          
          dotnet ef dbcontext scaffold `
            "Server=$(sqlServer);Database=$(sqlDatabase);Integrated Security=True;TrustServerCertificate=True;" `
            Microsoft.EntityFrameworkCore.SqlServer `
            --output-dir Entities `
            --context-dir . `
            --context HartonomousDbContext `
            --force `
            --no-build
          
          Write-Host "\u2713 Entities scaffolded"
        pwsh: true

# ============================================================================
# STAGE 4: BUILD .NET SOLUTION
# ============================================================================
- stage: BuildDotNet
  displayName: 'Build .NET Solution'
  dependsOn: ScaffoldEntities
  condition: succeeded()
  jobs:
  - job: BuildDotNetJob
    displayName: 'Build .NET Solution + CLR'
    pool:
      name: 'Local Agent Pool'
    steps:
    # Install .NET 10 SDK
    - task: UseDotNet@2
      displayName: 'Install .NET 10 SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetSdkVersion)'

    # Restore NuGet packages
    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet Packages'
      inputs:
        command: 'restore'
        projects: 'Hartonomous.sln'
        feedsToUse: 'select'

    # Build solution
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution (Release)'
      inputs:
        command: 'build'
        projects: 'Hartonomous.sln'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    # Run unit tests
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: 'test'
        projects: 'tests/**/*Tests.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --logger trx'
        publishTestResults: true

    # Publish applications
    - task: DotNetCoreCLI@2
      displayName: 'Publish Hartonomous.Api'
      inputs:
        command: 'publish'
        projects: 'src/Hartonomous.Api/Hartonomous.Api.csproj'
        publishWebProjects: false
        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/api'
        zipAfterPublish: false

    - task: DotNetCoreCLI@2
      displayName: 'Publish CesConsumer'
      inputs:
        command: 'publish'
        projects: 'src/Hartonomous.Workers.CesConsumer/Hartonomous.Workers.CesConsumer.csproj'
        publishWebProjects: false
        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/ces-consumer'
        zipAfterPublish: false

    - task: DotNetCoreCLI@2
      displayName: 'Publish Neo4jSync'
      inputs:
        command: 'publish'
        projects: 'src/Hartonomous.Workers.Neo4jSync/Hartonomous.Workers.Neo4jSync.csproj'
        publishWebProjects: false
        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/neo4j-sync'
        zipAfterPublish: false

    # Copy deployment scripts
    - task: CopyFiles@2
      displayName: 'Copy Deployment Scripts'
      inputs:
        SourceFolder: 'scripts'
        Contents: '**'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/scripts'

    # Copy procedure files
    - task: CopyFiles@2
      displayName: 'Copy Stored Procedures'
      inputs:
        SourceFolder: 'src/Hartonomous.Database/Procedures'
        Contents: '**/*.sql'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/database/Procedures'

    # Publish .NET artifacts
    - task: PublishPipelineArtifact@1
      displayName: 'Publish .NET Artifacts'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifact: 'dotnet'
        publishLocation: 'pipeline'

# ============================================================================
# STAGE 5: DEPLOY APPLICATIONS (Optional)
# ============================================================================
- stage: DeployApplications
  displayName: 'Deploy .NET Applications'
  dependsOn: BuildDotNet
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: AppDeployment
    displayName: 'Deploy Applications'
    environment: 'Application-Servers'
    pool:
      vmImage: 'windows-latest'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: dotnet

          - task: PowerShell@2
            displayName: 'Display Deployment Summary'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "========================================"
                Write-Host "  Hartonomous Deployment Complete"
                Write-Host "========================================"
                Write-Host "Database: $(sqlServer)\$(sqlDatabase)"
                Write-Host ""
                Write-Host "Artifacts Ready for Deployment:"
                Write-Host "  - API: $(Pipeline.Workspace)/dotnet/api"
                Write-Host "  - CesConsumer: $(Pipeline.Workspace)/dotnet/ces-consumer"
                Write-Host "  - Neo4jSync: $(Pipeline.Workspace)/dotnet/neo4j-sync"
                Write-Host ""
                Write-Host "Next Steps:"
                Write-Host "  1. Configure service connections"
                Write-Host "  2. Deploy to target servers"
                Write-Host "  3. Configure application settings"
                Write-Host "  4. Run smoke tests"
                Write-Host "========================================"
              pwsh: true
