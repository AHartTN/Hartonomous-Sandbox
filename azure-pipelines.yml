trigger:trigger:

  branches:  - main

    include:

      - mainpool:

      - develop  vmImage: 'ubuntu-latest'

  paths:

    exclude:variables:

      - docs/**  buildConfiguration: 'Release'

      - README.md  dotnetSdkVersion: '8.x'

      - LICENSE

stages:

pool:- stage: 'Build'

  vmImage: 'windows-latest'  displayName: 'Build the application'

  jobs:

variables:  - job: 'Build'

  buildConfiguration: 'Release'    displayName: 'Build job'

  dotnetVersion: '10.x'    steps:

  sqlServerInstance: 'localhost'    - task: UseDotNet@2

  databaseName: 'Hartonomous'      displayName: 'Install .NET SDK $(dotnetSdkVersion)'

      inputs:

stages:        packageType: 'sdk'

- stage: Build        version: '$(dotnetSdkVersion)'

  displayName: 'Build and Test'        performMultiLevelLookup: true

  jobs:

  - job: BuildProjects    - task: DotNetCoreCLI@2

    displayName: 'Build All Projects'      displayName: 'Restore project dependencies'

    steps:      inputs:

    - task: UseDotNet@2        command: 'restore'

      displayName: 'Install .NET 10 SDK'        projects: '**/*.csproj'

      inputs:

        packageType: 'sdk'    - task: DotNetCoreCLI@2

        version: '$(dotnetVersion)'      displayName: 'Build the project - $(buildConfiguration)'

        performMultiLevelLookup: true      inputs:

        command: 'build'

    - task: DotNetCoreCLI@2        arguments: '--no-restore --configuration $(buildConfiguration)'

      displayName: 'Restore Dependencies'        projects: '**/*.csproj'

      inputs:

        command: 'restore'    - task: DotNetCoreCLI@2

        projects: 'Hartonomous.sln'      displayName: 'Run unit tests'

      inputs:

    - task: DotNetCoreCLI@2        command: 'test'

      displayName: 'Build Solution'        projects: 'tests/**/*Tests.csproj'

      inputs:        arguments: '--no-build --configuration $(buildConfiguration) --collect:"XPlat Code Coverage"'

        command: 'build'

        projects: 'Hartonomous.sln'    - task: DotNetCoreCLI@2

        arguments: '--configuration $(buildConfiguration) --no-restore'      displayName: 'Publish Hartonomous.Api'

      inputs:

    - task: DotNetCoreCLI@2        command: 'publish'

      displayName: 'Run Unit Tests'        projects: 'src/Hartonomous.Api/Hartonomous.Api.csproj'

      inputs:        publishWebProjects: false

        command: 'test'        arguments: '--no-build --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/api'

        projects: 'tests/Hartonomous.UnitTests/Hartonomous.UnitTests.csproj'        zipAfterPublish: false

        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage"'        modifyOutputPath: false

        publishTestResults: true

    - task: DotNetCoreCLI@2

    - task: DotNetCoreCLI@2      displayName: 'Publish CesConsumer'

      displayName: 'Run Integration Tests'      inputs:

      inputs:        command: 'publish'

        command: 'test'        projects: 'src/CesConsumer/CesConsumer.csproj'

        projects: 'tests/Hartonomous.IntegrationTests/Hartonomous.IntegrationTests.csproj'        publishWebProjects: false

        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage"'        arguments: '--no-build --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/ces-consumer'

        publishTestResults: true        zipAfterPublish: false

        modifyOutputPath: false

    - task: DotNetCoreCLI@2

      displayName: 'Publish Web API'    - task: DotNetCoreCLI@2

      inputs:      displayName: 'Publish Neo4jSync'

        command: 'publish'      inputs:

        projects: 'src/Hartonomous.Api/Hartonomous.Api.csproj'        command: 'publish'

        publishWebProjects: false        projects: 'src/Neo4jSync/Neo4jSync.csproj'

        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/api'        publishWebProjects: false

        zipAfterPublish: false        arguments: '--no-build --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/neo4j-sync'

        zipAfterPublish: false

    - task: DotNetCoreCLI@2        modifyOutputPath: false

      displayName: 'Publish Model Ingestion Service'

      inputs:    - task: DotNetCoreCLI@2

        command: 'publish'      displayName: 'Publish ModelIngestion'

        projects: 'src/ModelIngestion/ModelIngestion.csproj'      inputs:

        publishWebProjects: false        command: 'publish'

        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/model-ingestion'        projects: 'src/ModelIngestion/ModelIngestion.csproj'

        zipAfterPublish: false        publishWebProjects: false

        arguments: '--no-build --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/model-ingestion'

    - task: DotNetCoreCLI@2        zipAfterPublish: false

      displayName: 'Publish CDC Consumer Service'        modifyOutputPath: false

      inputs:

        command: 'publish'    - task: CopyFiles@2

        projects: 'src/CesConsumer/CesConsumer.csproj'      displayName: 'Copy deployment scripts'

        publishWebProjects: false      inputs:

        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/ces-consumer'        SourceFolder: 'deploy'

        zipAfterPublish: false        Contents: '**'

        TargetFolder: '$(Build.ArtifactStagingDirectory)/deploy'

    - task: DotNetCoreCLI@2

      displayName: 'Publish Neo4j Sync Service'    - task: PublishBuildArtifacts@1

      inputs:      displayName: 'Publish build artifacts'

        command: 'publish'      inputs:

        projects: 'src/Neo4jSync/Neo4jSync.csproj'        PathtoPublish: '$(Build.ArtifactStagingDirectory)'

        publishWebProjects: false        ArtifactName: 'drop'

        arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)/neo4j-sync'        publishLocation: 'Container'

        zipAfterPublish: false

- stage: 'DeployDatabase'

    - task: DotNetCoreCLI@2  displayName: 'Deploy Database to HART-SERVER (Arc SQL)'

      displayName: 'Build SQL CLR Assembly'  dependsOn: Build

      inputs:  condition: succeeded()

        command: 'build'  jobs:

        projects: 'src/SqlClr/SqlClrFunctions.csproj'  - deployment: DeployDatabaseToArc

        arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/clr'    displayName: 'Deploy Database to Arc-enabled SQL Server'

    environment: 'hart-desktop-database'

    - task: CopyFiles@2    pool:

      displayName: 'Copy SQL Scripts'      vmImage: 'ubuntu-latest'

      inputs:    variables:

        SourceFolder: 'sql'      SQL_SERVER: 'HART-DESKTOP'

        Contents: '**/*.sql'      SQL_DATABASE: 'Hartonomous'

        TargetFolder: '$(Build.ArtifactStagingDirectory)/sql'      FILESTREAM_PATH: 'D:\SQLData\FILESTREAM'

    strategy:

    - task: CopyFiles@2      runOnce:

      displayName: 'Copy Deployment Scripts'        deploy:

      inputs:          steps:

        SourceFolder: 'scripts'          - checkout: self

        Contents: |            displayName: 'Checkout source for deployment scripts'

          deploy/**/*.ps1

          *.ps1          - download: current

          *.sql            artifact: drop

        TargetFolder: '$(Build.ArtifactStagingDirectory)/scripts'            displayName: 'Download build artifacts'



    - task: CopyFiles@2          - task: UseDotNet@2

      displayName: 'Copy Service Definitions'            displayName: 'Install .NET SDK for EF migrations'

      inputs:            inputs:

        SourceFolder: 'deploy'              packageType: 'sdk'

        Contents: '*.service'              version: '9.x'

        TargetFolder: '$(Build.ArtifactStagingDirectory)/deploy'              performMultiLevelLookup: true



    - task: PublishBuildArtifacts@1          - task: PowerShell@2

      displayName: 'Publish Build Artifacts'            displayName: 'Build UNSAFE CLR Assembly'

      inputs:            inputs:

        PathtoPublish: '$(Build.ArtifactStagingDirectory)'              targetType: 'inline'

        ArtifactName: 'drop'              script: |

        publishLocation: 'Container'                Write-Host "Building SqlClr project with UNSAFE permission set..."

                dotnet build src/SqlClr/SqlClrFunctions.csproj --configuration Release

- stage: DeployDatabase                

  displayName: 'Deploy Database'                $dllPath = "src/SqlClr/bin/Release/SqlClrFunctions.dll"

  dependsOn: Build                if (Test-Path $dllPath) {

  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))                  Write-Host "✓ CLR assembly built: $dllPath"

  jobs:                  $hash = (Get-FileHash $dllPath -Algorithm SHA256).Hash

  - deployment: DatabaseDeployment                  Write-Host "Assembly SHA256: $hash"

    displayName: 'Deploy Database and CLR'                  Copy-Item $dllPath -Destination "$(Build.ArtifactStagingDirectory)/clr/"

    environment: 'Production-Database'                } else {

    pool:                  Write-Error "CLR assembly not found at $dllPath"

      vmImage: 'windows-latest'                  exit 1

    strategy:                }

      runOnce:              pwsh: true

        deploy:

          steps:          - task: CopyFiles@2

          - download: current            displayName: 'Copy SQL deployment scripts'

            artifact: drop            inputs:

              SourceFolder: 'sql'

          - task: PowerShell@2              Contents: '**/*.sql'

            displayName: 'Deploy Database Schema and CLR'              TargetFolder: '$(Build.ArtifactStagingDirectory)/sql'

            inputs:

              targetType: 'inline'          - task: CopyFiles@2

              script: |            displayName: 'Copy PowerShell deployment scripts'

                $ErrorActionPreference = 'Stop'            inputs:

                              SourceFolder: 'scripts'

                Write-Host "========================================="              Contents: |

                Write-Host "  Hartonomous Database Deployment"                deploy/**/*.ps1

                Write-Host "========================================="                deploy-database.ps1

                                deployment-functions.ps1

                # Set variables                *.sql

                $serverInstance = "$(sqlServerInstance)"              TargetFolder: '$(Build.ArtifactStagingDirectory)/scripts'

                $database = "$(databaseName)"

                $scriptsPath = "$(Pipeline.Workspace)/drop/scripts"          - task: PublishPipelineArtifact@1

                $clrPath = "$(Pipeline.Workspace)/drop/clr/SqlClrFunctions.dll"            displayName: 'Publish database deployment package'

                            inputs:

                Write-Host "Server: $serverInstance"              targetPath: '$(Build.ArtifactStagingDirectory)'

                Write-Host "Database: $database"              artifact: 'database-deployment'

                Write-Host ""              publishLocation: 'pipeline'

                

                # Execute deployment script          - task: SSH@0

                & "$scriptsPath/deploy/deploy-database.ps1" `            displayName: 'Deploy database scripts to HART-DESKTOP via SSH'

                  -ServerInstance $serverInstance `            inputs:

                  -Database $database `              sshEndpoint: 'hart-desktop-ssh'

                  -AssemblyPath $clrPath `              runOptions: 'commands'

                  -Verbose              commands: |

                                # Create deployment directory on Windows Arc server

                if ($LASTEXITCODE -eq 0) {                powershell -Command "New-Item -ItemType Directory -Force -Path 'C:\Deploy\hartonomous\database' | Out-Null; Write-Host 'Deployment directory ready'"

                  Write-Host ""            

                  Write-Host "✓ Database deployment completed successfully" -ForegroundColor Green          - task: CopyFilesOverSSH@0

                } else {            displayName: 'Copy deployment package to HART-DESKTOP'

                  Write-Error "✗ Database deployment failed"            inputs:

                  exit 1              sshEndpoint: 'hart-desktop-ssh'

                }              sourceFolder: '$(Build.ArtifactStagingDirectory)'

              pwsh: true              contents: '**'

              targetFolder: 'C:\Deploy\hartonomous\database'

          - task: PowerShell@2              cleanTargetFolder: true

            displayName: 'Verify Database Deployment'              overwrite: true

            inputs:              failOnEmptySource: true

              targetType: 'inline'

              script: |          - task: SSH@0

                $query = @"            displayName: 'Execute database deployment on HART-DESKTOP'

                -- Verify assemblies            inputs:

                SELECT name, permission_set_desc, is_visible               sshEndpoint: 'hart-desktop-ssh'

                FROM sys.assemblies               runOptions: 'commands'

                WHERE name IN ('HartonomousSqlBridge', 'SqlClrFunctions');              commands: |

                                cd C:\Deploy\hartonomous\database

                -- Verify Service Broker

                SELECT is_broker_enabled                 # Execute deployment orchestrator with PowerShell

                FROM sys.databases                 powershell -ExecutionPolicy Bypass -File scripts\deploy\deploy-database.ps1 `

                WHERE name = '$(databaseName)';                  -ServerName "localhost" `

                                  -DatabaseName "$(SQL_DATABASE)" `

                -- Verify CLR functions                  -ScriptsDirectory "scripts\deploy" `

                SELECT COUNT(*) AS CLRFunctionCount                  -AssemblyPath "clr\SqlClrFunctions.dll" `

                FROM sys.objects o                  -ProjectPath "src\Hartonomous.Data\Hartonomous.Data.csproj" `

                WHERE o.type IN ('FN', 'FS', 'FT', 'AF')                  -SqlUser "$(SQL_USERNAME)" `

                  AND EXISTS (                  -SqlPassword (ConvertTo-SecureString -String "$(SQL_PASSWORD)" -AsPlainText -Force) `

                      SELECT 1                   -Verbose

                      FROM sys.assembly_modules am 

                      WHERE am.object_id = o.object_id                if ($LASTEXITCODE -eq 0) {

                  );                  Write-Host "✓ Database deployment completed successfully"

                "@                  exit 0

                                } else {

                sqlcmd -S "$(sqlServerInstance)" -d "$(databaseName)" -Q $query                  Write-Host "✗ Database deployment failed"

              pwsh: true                  exit 1

                }

- stage: DeployApplications

  displayName: 'Deploy Applications'          - bash: |

  dependsOn: DeployDatabase              echo "========================================" 

  condition: succeeded()              echo "  Database Deployment Summary"

  jobs:              echo "========================================"

  - deployment: ApiDeployment              echo "Target: $(SQL_SERVER) (Azure Arc-enabled)"

    displayName: 'Deploy Web API'              echo "Database: $(SQL_DATABASE)"

    environment: 'Production-API'              echo "CLR Mode: UNSAFE (on-premises only)"

    pool:              echo "FILESTREAM: $(FILESTREAM_PATH)"

      vmImage: 'windows-latest'              echo ""

    strategy:              echo "Artifacts published:"

      runOnce:              ls -lh $(Build.ArtifactStagingDirectory)/clr/

        deploy:              ls -lh $(Build.ArtifactStagingDirectory)/sql/

          steps:              echo "========================================"

          - download: current            displayName: 'Display deployment summary'

            artifact: drop

- stage: 'DeployToProduction'

          - task: IISWebAppManagementOnMachineGroup@0  displayName: 'Deploy to HART-SERVER Production'

            displayName: 'Create/Update IIS Application Pool'  dependsOn: 

            inputs:    - Build

              EnableIIS: true    - DeployDatabase

              IISDeploymentType: 'IISWebsite'  condition: succeeded()

              ActionIISWebsite: 'CreateOrUpdateAppPool'  jobs:

              AppPoolName: 'HartonomousApiPool'  - deployment: DeployServices

              DotNetVersion: 'No Managed Code'    displayName: 'Deploy Hartonomous Services'

              PipeLineMode: 'Integrated'    environment: 'hart-server-production'

              AppPoolIdentity: 'ApplicationPoolIdentity'    strategy:

      runOnce:

          - task: IISWebAppManagementOnMachineGroup@0        deploy:

            displayName: 'Create/Update IIS Website'          steps:

            inputs:          - download: current

              EnableIIS: true            artifact: drop

              IISDeploymentType: 'IISWebsite'

              ActionIISWebsite: 'CreateOrUpdateWebsite'          - bash: |

              WebsiteName: 'HartonomousApi'              echo "Installing systemd service files..."

              WebsitePhysicalPath: 'C:\inetpub\wwwroot\HartonomousApi'              mkdir -p ~/.config/systemd/user

              AddBinding: true              cp $(Pipeline.Workspace)/drop/deploy/*.service ~/.config/systemd/user/

              Bindings: |              systemctl --user daemon-reload

                {            displayName: 'Install systemd service files'

                  "bindings":[

                    {          - bash: |

                      "protocol":"http",              echo "Stopping services..."

                      "ipAddress":"*",              systemctl --user stop hartonomous-api hartonomous-ces-consumer hartonomous-neo4j-sync hartonomous-model-ingestion || true

                      "port":"5000",            displayName: 'Stop existing services'

                      "hostname":""

                    },          - bash: |

                    {              echo "Deploying API..."

                      "protocol":"https",              mkdir -p /srv/www/hartonomous/api

                      "ipAddress":"*",              cp -r $(Pipeline.Workspace)/drop/api/* /srv/www/hartonomous/api/

                      "port":"5001",              chmod +x /srv/www/hartonomous/api/Hartonomous.Api || true

                      "hostname":"",            displayName: 'Deploy API'

                      "sslThumbprint":"$(sslCertThumbprint)"

                    }          - bash: |

                  ]              echo "Deploying CesConsumer..."

                }              mkdir -p /srv/www/hartonomous/ces-consumer

              AppPoolName: 'HartonomousApiPool'              cp -r $(Pipeline.Workspace)/drop/ces-consumer/* /srv/www/hartonomous/ces-consumer/

              chmod +x /srv/www/hartonomous/ces-consumer/CesConsumer || true

          - task: IISWebAppDeploymentOnMachineGroup@0            displayName: 'Deploy CesConsumer'

            displayName: 'Deploy Web API to IIS'

            inputs:          - bash: |

              WebSiteName: 'HartonomousApi'              echo "Deploying Neo4jSync..."

              Package: '$(Pipeline.Workspace)/drop/api'              mkdir -p /srv/www/hartonomous/neo4j-sync

              TakeAppOfflineFlag: true              cp -r $(Pipeline.Workspace)/drop/neo4j-sync/* /srv/www/hartonomous/neo4j-sync/

              chmod +x /srv/www/hartonomous/neo4j-sync/Neo4jSync || true

  - deployment: BackgroundServicesDeployment            displayName: 'Deploy Neo4jSync'

    displayName: 'Deploy Background Services'

    environment: 'Production-Services'          - bash: |

    pool:              echo "Deploying ModelIngestion..."

      vmImage: 'windows-latest'              mkdir -p /srv/www/hartonomous/model-ingestion

    strategy:              cp -r $(Pipeline.Workspace)/drop/model-ingestion/* /srv/www/hartonomous/model-ingestion/

      runOnce:              chmod +x /srv/www/hartonomous/model-ingestion/ModelIngestion || true

        deploy:            displayName: 'Deploy ModelIngestion'

          steps:

          - download: current          - bash: |

            artifact: drop              echo "Starting services..."

              systemctl --user enable hartonomous-api hartonomous-ces-consumer hartonomous-neo4j-sync hartonomous-model-ingestion

          - task: PowerShell@2              systemctl --user start hartonomous-api hartonomous-ces-consumer hartonomous-neo4j-sync hartonomous-model-ingestion

            displayName: 'Deploy Model Ingestion Service'            displayName: 'Start services'

            inputs:

              targetType: 'inline'          - bash: |

              script: |              echo "Checking service status..."

                $serviceName = "HartonomousModelIngestion"              systemctl --user status hartonomous-api --no-pager || true

                $servicePath = "C:\Services\Hartonomous\ModelIngestion"              systemctl --user status hartonomous-ces-consumer --no-pager || true

                $exePath = "$servicePath\ModelIngestion.exe"              systemctl --user status hartonomous-neo4j-sync --no-pager || true

                              systemctl --user status hartonomous-model-ingestion --no-pager || true

                # Stop service if running            displayName: 'Verify service status'

                if (Get-Service -Name $serviceName -ErrorAction SilentlyContinue) {
                  Stop-Service -Name $serviceName -Force
                }
                
                # Copy files
                New-Item -ItemType Directory -Force -Path $servicePath | Out-Null
                Copy-Item -Path "$(Pipeline.Workspace)/drop/model-ingestion/*" -Destination $servicePath -Recurse -Force
                
                # Create/update service
                if (Get-Service -Name $serviceName -ErrorAction SilentlyContinue) {
                  sc.exe config $serviceName binPath= $exePath
                } else {
                  sc.exe create $serviceName binPath= $exePath start= auto DisplayName= "Hartonomous Model Ingestion"
                }
                
                # Start service
                Start-Service -Name $serviceName
                Write-Host "✓ Model Ingestion Service deployed and started"
              pwsh: true

          - task: PowerShell@2
            displayName: 'Deploy CDC Consumer Service'
            inputs:
              targetType: 'inline'
              script: |
                $serviceName = "HartonomousCesConsumer"
                $servicePath = "C:\Services\Hartonomous\CesConsumer"
                $exePath = "$servicePath\CesConsumer.exe"
                
                if (Get-Service -Name $serviceName -ErrorAction SilentlyContinue) {
                  Stop-Service -Name $serviceName -Force
                }
                
                New-Item -ItemType Directory -Force -Path $servicePath | Out-Null
                Copy-Item -Path "$(Pipeline.Workspace)/drop/ces-consumer/*" -Destination $servicePath -Recurse -Force
                
                if (Get-Service -Name $serviceName -ErrorAction SilentlyContinue) {
                  sc.exe config $serviceName binPath= $exePath
                } else {
                  sc.exe create $serviceName binPath= $exePath start= auto DisplayName= "Hartonomous CDC Event Consumer"
                }
                
                Start-Service -Name $serviceName
                Write-Host "✓ CDC Consumer Service deployed and started"
              pwsh: true

          - task: PowerShell@2
            displayName: 'Deploy Neo4j Sync Service'
            inputs:
              targetType: 'inline'
              script: |
                $serviceName = "HartonomousNeo4jSync"
                $servicePath = "C:\Services\Hartonomous\Neo4jSync"
                $exePath = "$servicePath\Neo4jSync.exe"
                
                if (Get-Service -Name $serviceName -ErrorAction SilentlyContinue) {
                  Stop-Service -Name $serviceName -Force
                }
                
                New-Item -ItemType Directory -Force -Path $servicePath | Out-Null
                Copy-Item -Path "$(Pipeline.Workspace)/drop/neo4j-sync/*" -Destination $servicePath -Recurse -Force
                
                if (Get-Service -Name $serviceName -ErrorAction SilentlyContinue) {
                  sc.exe config $serviceName binPath= $exePath
                } else {
                  sc.exe create $serviceName binPath= $exePath start= auto DisplayName= "Hartonomous Neo4j Synchronization"
                }
                
                Start-Service -Name $serviceName
                Write-Host "✓ Neo4j Sync Service deployed and started"
              pwsh: true

- stage: SmokeTest
  displayName: 'Smoke Test'
  dependsOn: DeployApplications
  condition: succeeded()
  jobs:
  - job: HealthCheck
    displayName: 'Run Health Checks'
    pool:
      vmImage: 'windows-latest'
    steps:
    - task: PowerShell@2
      displayName: 'Test API Health Endpoint'
      inputs:
        targetType: 'inline'
        script: |
          $apiUrl = "http://localhost:5000/health"
          Write-Host "Testing API health endpoint: $apiUrl"
          
          $response = Invoke-RestMethod -Uri $apiUrl -Method Get -TimeoutSec 30
          
          if ($response.status -eq "Healthy") {
            Write-Host "✓ API is healthy" -ForegroundColor Green
            exit 0
          } else {
            Write-Error "✗ API health check failed"
            Write-Host $response
            exit 1
          }
        pwsh: true

    - task: PowerShell@2
      displayName: 'Verify Services Running'
      inputs:
        targetType: 'inline'
        script: |
          $services = @(
            "HartonomousModelIngestion",
            "HartonomousCesConsumer",
            "HartonomousNeo4jSync"
          )
          
          $allHealthy = $true
          foreach ($service in $services) {
            $status = (Get-Service -Name $service).Status
            if ($status -eq "Running") {
              Write-Host "✓ $service is running" -ForegroundColor Green
            } else {
              Write-Host "✗ $service is not running (Status: $status)" -ForegroundColor Red
              $allHealthy = $false
            }
          }
          
          if (-not $allHealthy) {
            exit 1
          }
        pwsh: true

    - task: PowerShell@2
      displayName: 'Test Embedding Generation'
      inputs:
        targetType: 'inline'
        script: |
          $apiUrl = "http://localhost:5000/api/embedding/generate"
          $body = @{
            text = "Test embedding generation"
            modelIdentifier = "all-MiniLM-L6-v2"
          } | ConvertTo-Json
          
          Write-Host "Testing embedding generation..."
          
          try {
            $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Body $body -ContentType "application/json" -TimeoutSec 60
            
            if ($response.embeddingId -and $response.dimensions -eq 384) {
              Write-Host "✓ Embedding generation successful" -ForegroundColor Green
              Write-Host "Embedding ID: $($response.embeddingId)"
              Write-Host "Dimensions: $($response.dimensions)"
              exit 0
            } else {
              Write-Error "✗ Embedding response invalid"
              exit 1
            }
          } catch {
            Write-Error "✗ Embedding generation failed: $_"
            exit 1
          }
        pwsh: true
