# Archive Catalog Audit - Segment 002
**Scripts and Source-Level Documentation**

**Audit Date**: 2025-11-19  
**Files Reviewed**: 6  
**Segment Range**: Lines 1-500

---

## File: `.archive\scripts\README.md`

**Type**: Script Documentation / Index  
**Status**: Minimal Stub  
**File Size**: Very Small (~10 lines)

### Purpose
Brief index file listing Week 1 implementation scripts for build and deployment automation.

### Content Overview
Lists 4 script categories:
1. validate-build.ps1 - Build validation with comprehensive checks
2. deploy-dacpac.ps1 - Automated DACPAC deployment with rollback
3. smoke-tests.sql - Critical validation tests post-deployment
4. deploy-clr.ps1 - CLR-specific deployment automation

### Issues
- **Stub only** - No actual documentation content
- **Outdated references** - "Week 1 Implementation" suggests historical context
- **Missing details** - No usage examples, parameters, or actual script content
- **File existence** - Need to verify if referenced scripts actually exist

### Relationships
- **References**: 4 PowerShell/SQL scripts (not documented)
- **Related**: `.archive\src\Hartonomous.Database\DEPLOYMENT_PLAN.md` (actual deployment docs)

### Recommendation
**ACTION: Mark as Incomplete Stub**  
- This is a placeholder file with no substantive documentation
- Actual script documentation should come from script headers/inline comments
- Cross-reference with deployment plan for complete automation picture

---

## File: `.archive\scripts\GitHub-Secrets-Configuration.txt`

**Type**: Configuration Reference / Secrets Template  
**Status**: Live Configuration Data  
**File Size**: Medium (~100 lines)

### Purpose
Documents GitHub repository secrets configuration for CI/CD workflows with Azure authentication and SQL Server deployment.

### Configuration Data

**Repository-Level Secrets**:
- AZURE_SUBSCRIPTION_ID: ed614e1a-7d8b-4608-90c8-66e86c37080b
- AZURE_TENANT_ID: 6c9c44c4-f04b-4b5f-bea0-f1069179799c
- SQL_SERVER: HART-DESKTOP
- SQL_DATABASE: Hartonomous

**Environment-Specific Secrets** (DEVELOPMENT/STAGING/PRODUCTION):
- DEVELOPMENT: AZURE_CLIENT_ID = 66a37c0f-5666-450b-b61f-c9e33b56115e
- STAGING: AZURE_CLIENT_ID = f05370b1-d09f-4085-bd04-ac028c28b7f8
- PRODUCTION: AZURE_CLIENT_ID = 48a904b7-f070-407d-abab-1b71a3c049a9

### Technical Details
- **Authentication**: Azure OIDC (OpenID Connect) with service principals
- **Deployment Target**: HART-DESKTOP local SQL Server
- **Database**: Hartonomous
- **GitHub Actions**: Uses azure/login@v2 action

### Security Concerns
- **⚠️ SENSITIVE DATA**: Contains real Azure subscription IDs, tenant IDs, and client IDs
- **⚠️ SQL SERVER NAME**: Exposes internal server hostname (HART-DESKTOP)
- **Local Development**: Assumes local SQL Server deployment

### Relationships
- **Used By**: GitHub Actions workflows (azure-pipelines.yml)
- **Related**: Azure service principal configurations
- **References**: SQL deployment scripts

### Recommendation
**ACTION: SECURITY REVIEW REQUIRED**  
- **DO NOT** expose this file in public documentation
- Keep in archive for reference but mark as CONFIDENTIAL
- Consider if these secrets are still active/valid
- Document pattern/template only, not actual values
- Move to secure secret management (Azure Key Vault, GitHub Secrets)

---

## File: `.archive\src\Hartonomous.Database\README.md`

**Type**: Database Project Documentation / Quickstart  
**Status**: Current/Active Template  
**File Size**: Small (~30 lines)

### Purpose
Quickstart guide for the SQL Database Project using new SDK-style Microsoft.Build.Sql tooling.

### Key Information

**Build Process**:
```bash
dotnet build
```
Output: `dacpac` file for deployment anywhere

**Publish Process**:
```bash
sqlpackage /Action:Publish \
  /SourceFile:bin/Debug/Hartonomous.Database.dacpac \
  /TargetServerName:localhost \
  /TargetDatabaseName:Hartonomous.Database
```

**SqlPackage Installation**:
```bash
dotnet tool install -g microsoft.sqlpackage
```
Available for Windows, macOS, Linux

### Technical Details
- **SDK-Style Project**: Microsoft.Build.Sql (modern .NET tooling)
- **Output**: DACPAC (Data-tier Application Package)
- **Deployment Tool**: SqlPackage CLI (cross-platform)
- **Reference**: https://aka.ms/sqlpackage-ref

### Quality Assessment
- ✅ Clear and concise
- ✅ Modern tooling (SDK-style project)
- ✅ Cross-platform support
- ✅ External reference links
- ❌ Minimal (could use more context about project structure)

### Relationships
- **Companion**: `.archive\src\Hartonomous.Database\DEPLOYMENT_PLAN.md` (comprehensive deployment guide)
- **Generated By**: Database project scaffolding/template
- **References**: Microsoft.Build.Sql SDK, SqlPackage documentation

### Recommendation
**ACTION: Keep and Enhance**  
- This is current, valid documentation for the database project
- Consider enhancing with:
  - Project structure overview
  - Development workflow
  - Testing procedures
  - Link to comprehensive DEPLOYMENT_PLAN.md
- Promote to `docs/implementation/database-project-setup.md`

---

## File: `.archive\src\Hartonomous.Database\DEPLOYMENT_PLAN.md`

**Type**: Deployment Guide / Architecture Documentation  
**Status**: Current/Critical  
**File Size**: Large (~450 lines)

### Purpose
Comprehensive deployment guide for Hartonomous database, explaining three-component deployment architecture and detailed procedures.

### Three-Component Architecture

**Component 1: DACPAC** (Schema-only)
- 56 Tables (dbo, graph, provenance schemas)
- 2 Schemas
- Indexes (clustered, nonclustered, spatial, graph)
- Foreign keys and constraints
- **Size**: 22KB
- **Deploy**: SqlPackage CLI or Visual Studio

**Component 2: CLR Deployment**
- SqlClrFunctions.dll assembly
- Vector operations (clr_VectorAdd, clr_VectorDotProduct, etc.)
- Aggregates (clr_VectorAverage, clr_DBSCANCluster, etc.)
- UDTs (AtomicStream, ComponentStream)
- Spatial functions, stream orchestrators
- **Deploy**: deploy-clr-secure.ps1 script

**Component 3: Runtime Scripts**
- 63 Stored Procedures (multi-procedure files excluded from DACPAC)
- 3 Post-deployment scripts (ALTER TABLE statements)
- 3 Migration scripts (optional advanced features)
- **Deploy**: deploy-database-unified.ps1 or manual execution

### Files Excluded from DACPAC (Why)
1. **Procedures** (63 files) - Multi-procedure syntax incompatible with DACPAC one-object-per-file requirement
2. **CLR UDTs** (2 types) - Assembly introspection limitation
3. **CLR Tables** (1 table) - Uses CLR UDT, deploy after CLR
4. **Post-Deploy Scripts** (3 files) - ALTER TABLE incompatible with declarative schema
5. **Migration Scripts** (3 files) - ALTER DATABASE statements

### Key Procedures Listed
- **Agent Framework**: sp_Act, sp_Analyze, sp_Learn, sp_Hypothesize
- **Atom Ingestion**: sp_AtomIngestion, sp_AtomizeImage, sp_AtomizeAudio, sp_AtomizeCode
- **Inference**: ServiceBrokerActivation, VectorSearchSuite, SpatialGenerationSuite
- **Provenance**: Neo4jSyncActivation, ProvenanceTracking
- **Search**: SemanticSearch, VectorSearch, FullTextSearch
- **Generation**: TextFromVector, ImageFromPrompt, AudioFromPrompt
- **Billing**: InsertUsageRecord_Native, BillingFunctions

### Deployment Order (Clean Install)
1. DACPAC (schema baseline)
2. CLR assemblies (functions, aggregates, UDTs)
3. CLR-dependent table (GenerationStreams)
4. Post-deployment ALTER scripts (3 files)
5. Stored procedures (all 63 files)

**Unified script option**: deploy-database-unified.ps1

### Data Safety Assessment
- ✅ **NO DATA LOSS** - Schema only (no DELETE/DROP/TRUNCATE)
- ✅ **No Breaking Changes** - Additive only
- ⚠️ **Procedure Updates** - Need re-execution if signatures changed

### Future Improvements Listed
1. Split procedures (one-per-file for DACPAC inclusion)
2. CLR UDT workaround (use VARBINARY instead)
3. Post-deployment automation wrapper
4. CI/CD integration (Azure Pipelines)

### Quality Assessment
- ✅ Comprehensive and well-structured
- ✅ Clear component separation
- ✅ Deployment order specified
- ✅ Risk assessment included
- ✅ Future roadmap defined
- ✅ Multiple deployment options

### Relationships
- **Core Document**: Primary deployment reference
- **Companion**: README.md (quick start)
- **References**: Multiple PowerShell scripts
- **Related**: SANITY_CHECK_RESULTS.md (verification)

### Recommendation
**ACTION: Promote to Core Documentation**  
- This is **CRITICAL** deployment documentation
- Promote to `docs/operations/database-deployment.md`
- Keep updated as deployment process evolves
- Add to required reading for ops team
- Cross-reference with CI/CD pipeline docs

---

## File: `.archive\src\Hartonomous.Database\SANITY_CHECK_RESULTS.md`

**Type**: Verification Report / Status Document  
**Status**: Historical Snapshot  
**File Size**: Large (~300 lines)

### Purpose
Post-migration verification report documenting successful DACPAC build after database project migration.

### Key Findings

**Status**: ✅ **PASSED** (November 10, 2025)

**Component Inventory**:
- ✅ Tables: 56 files (vs 30 original - split multi-table files)
- ✅ Procedures: 63 files (vs 65 original - 2 moved to Common.ClrBindings.sql)
- ✅ CLR Components: SqlClrFunctions.dll (295.5 KB)
- ✅ Post-Deployment Scripts: 3 files
- ✅ Schemas: 2 files (provenance, graph)
- ✅ DACPAC Artifact: 21.74 KB, 0 errors

**Files Added** (140 new files):
- SQL Database Project with DACPAC-compatible syntax
- 56 table files (migrated and split)
- 63 procedure files
- 2 schema files
- 2 CLR UDT files
- 3 post-deployment scripts
- Helper scripts

**Files Excluded from Build**:
- Procedures (63) - Multi-procedure incompatibility
- CLR UDTs (2) - Deployed via CLR script
- GenerationStreams table (1) - Uses CLR UDT
- Migration scripts (3) - ALTER DATABASE incompatible
- Post-deployment scripts (3) - ALTER TABLE incompatible

### Data Integrity Verification
- ✅ No data loss risk (schema only)
- ✅ No breaking changes (additive only)
- ✅ Deployment path preserved (original sql/ intact)

### Warnings (Non-Critical)
1. Missing tables from sql/tables/ - Expected (were split)
2. Deployment script paths - Reference old sql/procedures/ location

### Quality Assessment
- ✅ Comprehensive verification
- ✅ Clear component accounting
- ✅ Risk assessment
- ✅ Deployment checklist
- ✅ Timestamped snapshot (Nov 10, 2025)
- ⚠️ Historical point-in-time document

### Relationships
- **Verifies**: DEPLOYMENT_PLAN.md accuracy
- **Generated By**: scripts/dacpac-sanity-check.ps1
- **Timestamp**: November 10, 2025 (9 days ago from audit date)
- **Status**: Snapshot, not living document

### Recommendation
**ACTION: Archive as Historical Reference**  
- Document represents successful migration milestone
- Useful for understanding migration decisions
- **DO NOT** use as current status (dated Nov 10)
- Generate new sanity check report for current state
- Keep in archive as migration audit trail

---

## File: `.archive\src\Hartonomous.Data.Entities\Abstracts\README.md`

**Type**: Architecture Guide / Design Philosophy  
**Status**: Current/Critical  
**File Size**: Large (~350 lines)

### Purpose
Comprehensive guide to entity scaffolding strategy and lightweight projection pattern for EF Core entities.

### Core Philosophy: Schema-First, Not Opinionated

**Auto-Generated (Scaffolded)**:
- Entities/ - Pure POCOs matching database schema
- Configurations/ - EF Core fluent API (separate files)
- HartonomousDbContext.cs - DbContext with ApplyConfiguration

**Hand-Written (NOT Scaffolded)**:
- Abstracts/ - Interfaces and base classes for app layer
- Partial class extensions - Interface implementations
- Domain logic - Business rules, validations

### Why Not Auto-Generate Everything?
1. **Temporal Tables** - SQL Server system versioning makes audit fields redundant
2. **Schema Diversity** - 65+ tables with different patterns (temporal, standard, multi-tenant)
3. **Flexibility** - Opt-in interfaces based on usage patterns
4. **Performance** - Avoid forcing patterns on tables that don't need them

### Lightweight Projection Pattern

**Problem**: Loading entire entity graph unnecessarily
```csharp
// BAD: N+1 queries loading all navigation properties
public void ProcessAtom(Atom atom) { var id = atom.AtomId; }
```

**Solution**: Interface projection for minimal data transfer
```csharp
// GOOD: Just ID, no graph
public void ProcessAtom(IIdentifiable<long> atom) { var id = atom.Id; }
```

**Implementation**: Partial classes bridge data and app layers
```csharp
// Entities/Atom.Partial.cs
public partial class Atom : IIdentifiable<long>, ITenantScoped<long>
{
    long IIdentifiable<long>.Id => AtomId;
    int ITenantScoped<long>.TenantId => TenantId;
}
```

### Available Abstracts

**Marker Interfaces**:
- IEntity - Base marker
- IEntity<TKey> - Entity with primary key

**Projection Interfaces**:
- IIdentifiable<TKey> - Just ID, no graph
- ITimestamped<TKey> - ID + CreatedAt
- ITenantScoped<TKey> - ID + TenantId

**Audit Interfaces**:
- IAuditableEntity - Created/Modified tracking
- ISoftDeletable - Soft delete pattern
- IConcurrencyToken - Optimistic concurrency

**Base Classes**:
- EntityBase<TKey> - For hand-written domain entities only

### Usage Guidelines

**Use Projection Interfaces For**:
- ✅ Service method parameters (avoid graph loading)
- ✅ Batch operations (IDs only)
- ✅ API responses (minimal data)
- ✅ Query projections

**Use EntityBase For**:
- ✅ Custom domain entities (hand-written)
- ✅ Aggregate roots with business logic
- ❌ **NEVER** for scaffolded database entities

**Use Audit Interfaces For**:
- ✅ Hand-written entities needing audit trails
- ❌ Temporal tables (SQL Server handles automatically)
- ❌ Scaffolded entities (schema controls)

### Scaffolding Workflow
1. Modify database schema
2. Run scaffolding: `.\scripts\scaffold-entities.ps1`
3. Entities regenerated (pure POCOs)
4. Add partial classes (implement interfaces as needed)
5. Update services (use projections)

### Anti-Patterns Documented

**❌ DON'T**:
- Force EntityBase on scaffolded entities
- Add query filters during scaffolding (redundant for temporal)
- Pass full entities to services (graph loading overhead)

**✅ DO**:
- Use projections (IIdentifiable, ITenantScoped)
- Partial classes for interface implementations
- Lightweight DTOs for APIs

### Quality Assessment
- ✅ Clear architectural guidance
- ✅ Well-reasoned design decisions
- ✅ Practical code examples
- ✅ Anti-patterns documented
- ✅ Performance-conscious
- ✅ Flexible, opt-in approach

### Relationships
- **Guides**: Entity scaffolding strategy
- **Related**: scripts/scaffold-entities.ps1
- **Architecture**: Schema-first data layer design
- **Pattern**: Lightweight projection for performance

### Recommendation
**ACTION: Promote to Core Architecture Documentation**  
- This is **CRITICAL** architecture guidance for data layer
- Promote to `docs/architecture/entity-scaffolding-strategy.md`
- Add to required reading for developers
- Reference from data access documentation
- Keep updated as EF Core patterns evolve

---

## Summary Statistics - Segment 002

**Files Reviewed**: 6  
**Total Lines Analyzed**: ~1,240 lines  
**Document Types**:
- Configuration: 1 (SECURITY SENSITIVE)
- Quickstart: 1
- Deployment Guide: 1 (CRITICAL)
- Verification Report: 1 (Historical)
- Architecture Guide: 1 (CRITICAL)
- Stub/Placeholder: 1

**Key Findings**:
1. **Security Risk**: GitHub-Secrets-Configuration.txt contains sensitive Azure/SQL credentials
2. **Critical Docs**: DEPLOYMENT_PLAN.md and Abstracts/README.md are essential architecture documentation
3. **Historical Snapshot**: SANITY_CHECK_RESULTS.md is point-in-time verification (Nov 10)
4. **Stub File**: scripts/README.md has no substantive content

**Actions Required**:
- **SECURITY**: Secure or redact GitHub-Secrets-Configuration.txt (1 file)
- **Promote**: DEPLOYMENT_PLAN.md and Abstracts/README.md to core docs (2 files)
- **Enhance**: Database project README.md with more context (1 file)
- **Archive**: SANITY_CHECK_RESULTS.md as historical reference (1 file)
- **Ignore**: scripts/README.md stub (1 file)

---

**Next Segment**: docs_old structure (architecture, examples, operations, getting-started)  
**Estimated Files**: ~25 markdown files in nested structure
