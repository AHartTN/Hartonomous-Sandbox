# Hartonomous - Clean Architecture

This document describes the new clean architecture structure for Hartonomous.

## Project Structure

```
src/
├── Hartonomous.Core/              # Domain layer (entities, value objects)
│   └── Entities/                  # Domain entities with navigation properties
├── Hartonomous.Data/              # Data access layer (EF Core)
│   ├── Configurations/            # Entity configurations (Fluent API)
│   ├── Migrations/                # EF Core migrations
│   └── HartonomousDbContext.cs    # Main DbContext
├── Hartonomous.Infrastructure/    # Infrastructure layer (repositories, services)
│   ├── Repositories/              # Repository implementations
│   └── DependencyInjection.cs     # DI registration
├── ModelIngestion/                # Application: Model ingestion service
├── CesConsumer/                   # Application: Change Event Stream consumer
└── Neo4jSync/                     # Application: Neo4j synchronization
```

## Layer Responsibilities

### Core (Domain)
- **Purpose**: Define business entities and domain logic
- **Dependencies**: None (pure domain)
- **Contains**:
  - Entity classes (`Model`, `Embedding`, `InferenceRequest`, etc.)
  - Value objects (if needed)
  - Domain interfaces (if needed)

### Data (Persistence)
- **Purpose**: EF Core DbContext and entity configurations
- **Dependencies**: Core
- **Contains**:
  - `HartonomousDbContext` - main DbContext
  - Entity configurations using Fluent API
  - Migrations (generated by EF Core tools)
  - Custom SQL type mappings (VECTOR, GEOMETRY)

### Infrastructure (Implementation)
- **Purpose**: Repository implementations and cross-cutting concerns
- **Dependencies**: Core, Data
- **Contains**:
  - Repository interfaces and implementations
  - DI registration extensions
  - Configuration management
  - Health checks
  - External service integrations (future: Neo4j driver, Azure Event Hubs)

### Applications (Entry Points)
- **Purpose**: Console apps, services, APIs
- **Dependencies**: Core, Data, Infrastructure
- **Contains**:
  - Program.cs with DI setup
  - Application-specific logic
  - Configuration (appsettings.json)

## Using the New Structure

### 1. Register Services in Your Application

```csharp
using Hartonomous.Infrastructure;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

var builder = Host.CreateApplicationBuilder(args);

// Add Hartonomous infrastructure (DbContext + Repositories)
builder.Services.AddHartonomousInfrastructure(builder.Configuration);

// Add health checks
builder.Services.AddHartonomousHealthChecks(builder.Configuration);

var host = builder.Build();
await host.RunAsync();
```

### 2. Configure Connection String

Add to `appsettings.json`:

```json
{
  "ConnectionStrings": {
    "HartonomousDb": "Server=localhost;Database=Hartonomous;Trusted_Connection=True;TrustServerCertificate=True;MultipleActiveResultSets=true"
  }
}
```

### 3. Use Repositories via DI

```csharp
public class MyService
{
    private readonly IModelRepository _modelRepository;
    private readonly IEmbeddingRepository _embeddingRepository;
    private readonly ILogger<MyService> _logger;

    public MyService(
        IModelRepository modelRepository,
        IEmbeddingRepository embeddingRepository,
        ILogger<MyService> logger)
    {
        _modelRepository = modelRepository;
        _embeddingRepository = embeddingRepository;
        _logger = logger;
    }

    public async Task DoWorkAsync(CancellationToken cancellationToken)
    {
        // Get a model
        var model = await _modelRepository.GetByNameAsync("bert-base", cancellationToken);
        
        // Perform vector search
        var results = await _embeddingRepository.ExactSearchAsync(
            queryVector: "[0.1, 0.2, ...]",
            topK: 10,
            metric: "cosine",
            cancellationToken: cancellationToken);
    }
}
```

## EF Core Migrations

### Create Initial Migration

```powershell
cd src/Hartonomous.Data
dotnet ef migrations add InitialCreate --startup-project ../ModelIngestion
```

### Apply Migration

```powershell
dotnet ef database update --startup-project ../ModelIngestion
```

### Add New Migration (after model changes)

```powershell
dotnet ef migrations add YourMigrationName --startup-project ../ModelIngestion
dotnet ef database update --startup-project ../ModelIngestion
```

## VECTOR Type Support

EF Core doesn't natively support SQL Server 2025 VECTOR types. We handle this by:

1. **In C#**: Store as `string` (JSON array format: `"[1.0, 2.0, 3.0]"`)
2. **In DB**: Configure as `VECTOR(n)` using Fluent API
3. **Mapping**: EF Core treats it as `nvarchar`, but SQL Server stores as native VECTOR

Example from `EmbeddingConfiguration.cs`:

```csharp
builder.Property(e => e.EmbeddingFull)
    .HasColumnName("embedding_full")
    .HasColumnType("VECTOR(768)");
```

When inserting, pass JSON string:
```csharp
var embedding = new Embedding
{
    EmbeddingFull = "[0.1, 0.2, 0.3, ...]", // 768 values
    // ...
};
```

SQL Server automatically converts between JSON and VECTOR.

## Repository Pattern

All data access goes through repositories:

- **`IModelRepository`** - Model CRUD operations
- **`IEmbeddingRepository`** - Embedding operations + vector search
- **`IInferenceRepository`** - Inference tracking and analytics

Repositories:
- Use async/await throughout
- Accept `CancellationToken` for cancellation support
- Use `ILogger` for diagnostics
- Call stored procedures for complex operations (vector search)

## Best Practices

1. **Always use repositories** - Don't inject `DbContext` directly into application code
2. **Use CancellationToken** - Pass it through all async methods
3. **Log appropriately** - Use structured logging with `ILogger<T>`
4. **Configure via appsettings.json** - Don't hardcode connection strings
5. **Use migrations** - Keep database schema in code, not SQL scripts
6. **Test with InMemory provider** - For unit tests, use EF Core InMemory provider

## Migration from Old Code

Old (direct ADO.NET):
```csharp
using var connection = new SqlConnection(_connectionString);
await connection.OpenAsync();
var command = new SqlCommand("INSERT INTO...", connection);
await command.ExecuteNonQueryAsync();
```

New (EF Core + Repository):
```csharp
var model = new Model
{
    ModelName = "bert-base",
    ModelType = "transformer"
};
await _modelRepository.AddAsync(model, cancellationToken);
```

## Next Steps

1. Update existing services (`ModelIngestion`, `CesConsumer`, `Neo4jSync`) to use new structure
2. Create migrations from code-first models
3. Add integration tests for repositories
4. Add application services layer (business logic between controllers/endpoints and repositories)
5. Consider adding MediatR for CQRS pattern (if building an API)
