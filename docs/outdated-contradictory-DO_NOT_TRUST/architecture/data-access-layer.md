# Hartonomous Data Access Architecture

## ğŸ—ï¸ Architecture Overview

Hartonomous implements a **database-first, specification-driven data access layer** following Clean Architecture, SOLID principles, and enterprise patterns. The architecture separates concerns across multiple layers with clear boundaries and abstractions.

### Layer Hierarchy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Hartonomous.Core (Business Logic Layer)               â”‚
â”‚  â”œâ”€â”€ Data/                                              â”‚
â”‚  â”‚   â”œâ”€â”€ IEntity.cs          (Entity contracts)        â”‚
â”‚  â”‚   â”œâ”€â”€ IRepository.cs      (Repository contracts)    â”‚
â”‚  â”‚   â”œâ”€â”€ ISpecification.cs   (Query specifications)    â”‚
â”‚  â”‚   â”œâ”€â”€ IUnitOfWork.cs      (Transaction management)  â”‚
â”‚  â”‚   â”œâ”€â”€ IDbContextFactory.cs (Context factory)        â”‚
â”‚  â”‚   â””â”€â”€ IScaffoldingService.cs (Scaffolding service)  â”‚
â”‚  â””â”€â”€ (No EF Core dependencies)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â–²
                           â”‚ Depends on
                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Hartonomous.Infrastructure (Implementation Layer)      â”‚
â”‚  â”œâ”€â”€ Data/                                              â”‚
â”‚  â”‚   â”œâ”€â”€ EfRepository.cs     (EF Core repository impl) â”‚
â”‚  â”‚   â”œâ”€â”€ EfUnitOfWork.cs     (EF Core UoW impl)        â”‚
â”‚  â”‚   â””â”€â”€ (EF Core concrete implementations)            â”‚
â”‚  â””â”€â”€ (References EF Core NuGet packages)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â–²
                           â”‚ Depends on
                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Hartonomous.Data (Database-First Entity Layer)         â”‚
â”‚  â”œâ”€â”€ Entities/         (Generated by EF Core scaffold)  â”‚
â”‚  â”‚   â”œâ”€â”€ Model.cs                                       â”‚
â”‚  â”‚   â”œâ”€â”€ Atom.cs                                        â”‚
â”‚  â”‚   â”œâ”€â”€ AtomEmbedding.cs                              â”‚
â”‚  â”‚   â””â”€â”€ ... (40+ entities from SQL Server schema)     â”‚
â”‚  â”œâ”€â”€ HartonomousDbContext.cs  (Generated DbContext)    â”‚
â”‚  â””â”€â”€ HartonomousDbContext.Partial.cs (Custom logic)    â”‚
â”‚  â””â”€â”€ (100% code-generated from database schema)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â–²
                           â”‚ Represents
                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SQL Server 2025 Database (Source of Truth)             â”‚
â”‚  â”œâ”€â”€ Deployed via DACPAC (Hartonomous.Database.sqlproj)â”‚
â”‚  â”œâ”€â”€ Contains: Tables, Views, Stored Procedures, CLR   â”‚
â”‚  â””â”€â”€ Bleeding-edge: VECTOR(1998), Native JSON, Preview â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Design Patterns Implemented

### 1. **Repository Pattern** (`IRepository<TEntity, TKey>`)
**Purpose**: Abstract data access logic from business logic.

**Benefits**:
- âœ… Decouples business logic from EF Core
- âœ… Enables unit testing with mock repositories
- âœ… Centralizes query logic
- âœ… Type-safe entity access

**Example**:
```csharp
// Interface (in Hartonomous.Core)
public interface IRepository<TEntity, TKey> 
    where TEntity : class, IEntity<TKey> 
    where TKey : IEquatable<TKey>
{
    Task<TEntity?> GetByIdAsync(TKey id, CancellationToken ct = default);
    Task<IReadOnlyList<TEntity>> FindAsync(Expression<Func<TEntity, bool>> predicate, CancellationToken ct = default);
    Task<TEntity> AddAsync(TEntity entity, CancellationToken ct = default);
    void Update(TEntity entity);
    void Remove(TEntity entity);
}

// Implementation (in Hartonomous.Infrastructure)
public class EfRepository<TEntity, TKey> : IRepository<TEntity, TKey> { /* ... */ }

// Usage (in application code)
var modelRepo = unitOfWork.Repository<Model, long>();
var model = await modelRepo.GetByIdAsync(123);
```

### 2. **Unit of Work Pattern** (`IUnitOfWork`)
**Purpose**: Manage database transactions and coordinate repository operations.

**Benefits**:
- âœ… Ensures atomic operations across multiple repositories
- âœ… Centralizes transaction management
- âœ… Reduces boilerplate SaveChanges calls
- âœ… Supports nested transactions

**Example**:
```csharp
await unitOfWork.ExecuteInTransactionAsync(async () =>
{
    var modelRepo = unitOfWork.Repository<Model, long>();
    var atomRepo = unitOfWork.Repository<Atom, long>();
    
    var model = await modelRepo.GetByIdAsync(modelId);
    model.LastAccessedAt = DateTime.UtcNow;
    
    var atoms = await atomRepo.FindAsync(a => a.ModelId == modelId);
    // ... complex business logic across multiple repositories
    
    // Single transaction commit
});
```

### 3. **Specification Pattern** (`ISpecification<TEntity>`)
**Purpose**: Encapsulate query logic in reusable, composable, testable specifications.

**Benefits**:
- âœ… DRY: Reusable query logic
- âœ… Testable: Specifications can be unit tested independently
- âœ… Composable: Combine specifications with AND/OR logic
- âœ… Maintainable: Complex queries isolated in dedicated classes

**Example**:
```csharp
// Define a specification (in Hartonomous.Core)
public class ActiveModelsSpecification : Specification<Model>
{
    public ActiveModelsSpecification(string nameFilter, int pageSize, int pageNumber)
    {
        AddCriteria(m => !m.IsDeleted && m.Name.Contains(nameFilter));
        AddInclude(m => m.ModelLayers);
        AddOrderByDescending(m => m.CreatedAt);
        ApplyPaging(pageNumber * pageSize, pageSize);
        ApplyNoTracking(); // Read-only query optimization
    }
}

// Usage
var spec = new ActiveModelsSpecification("gpt", pageSize: 20, pageNumber: 0);
var models = await modelRepo.FindAsync(spec);
```

### 4. **Factory Pattern** (`IDbContextFactory<TContext>`)
**Purpose**: Control DbContext lifecycle in multi-tenant or connection-string-override scenarios.

**Benefits**:
- âœ… Supports multi-tenancy
- âœ… Enables connection string resolution at runtime
- âœ… Facilitates testing with different databases
- âœ… Allows per-request DbContext creation

---

## ğŸ”§ Entity Contracts (Marker Interfaces)

### Hierarchy of Entity Interfaces

```csharp
IEntity                           // Base marker interface
  â””â”€â”€ IEntity<TKey>               // Entities with primary key
        â”œâ”€â”€ IAuditable            // Created/Modified timestamps
        â”œâ”€â”€ ISoftDeletable        // Soft delete support
        â”œâ”€â”€ IConcurrent           // Optimistic concurrency (RowVersion)
        â””â”€â”€ IFullyAuditedEntity<TKey> // All above combined
```

**Why Marker Interfaces?**
- âœ… Generic constraints: `where TEntity : IEntity<TKey>`
- âœ… Cross-cutting concerns: Automatic audit trail injection
- âœ… Query filters: Global soft-delete filtering
- âœ… Polymorphic repository access

**Example Entity**:
```csharp
// Generated by scaffolding (Hartonomous.Data/Entities/Model.cs)
public partial class Model : IEntity<long>, IAuditable, ISoftDeletable
{
    public long Id { get; set; }
    public string Name { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ModifiedAt { get; set; }
    public string? CreatedBy { get; set; }
    public string? ModifiedBy { get; set; }
    public bool IsDeleted { get; set; }
    public DateTime? DeletedAt { get; set; }
    public string? DeletedBy { get; set; }
}
```

---

## ğŸ”„ Database-First Workflow

### Automated Entity Scaffolding

```bash
# 1. Deploy DACPAC (updates SQL Server schema)
.\scripts\deploy-dacpac.ps1

# 2. Entities automatically regenerated after deployment
# (Integrated into deploy-dacpac.ps1 as Phase 5)

# 3. Manual regeneration (if needed)
.\scripts\generate-entities.ps1 -Force
```

### Scaffolding Process

1. **DACPAC Deployment** â†’ SQL Server schema updated
2. **`dotnet ef dbcontext scaffold`** â†’ Reads database metadata
3. **Entity Generation** â†’ Creates C# classes in `Hartonomous.Data/Entities/`
4. **Partial Classes Preserved** â†’ Custom logic not overwritten
5. **Build Verification** â†’ Ensures generated code compiles

### Idempotent Regeneration

**Key Principle**: Generated code is **overwritten**, custom code is **preserved**.

```
Hartonomous.Data/
â”œâ”€â”€ Entities/                      (REGENERATED - do not edit)
â”‚   â”œâ”€â”€ Model.cs
â”‚   â”œâ”€â”€ Atom.cs
â”‚   â””â”€â”€ AtomEmbedding.cs
â”œâ”€â”€ HartonomousDbContext.cs        (REGENERATED - do not edit)
â””â”€â”€ HartonomousDbContext.Partial.cs (PRESERVED - add custom logic here)
```

**Example Partial Class** (`HartonomousDbContext.Partial.cs`):
```csharp
public partial class HartonomousDbContext
{
    partial void OnModelCreatingPartial(ModelBuilder modelBuilder)
    {
        // Custom configurations override scaffolded ones
        modelBuilder.Entity<Model>()
            .HasQueryFilter(m => !m.IsDeleted); // Global soft-delete filter
        
        // Custom value converters for SQL Server 2025 VECTOR type
        modelBuilder.Entity<AtomEmbedding>()
            .Property(e => e.VectorData)
            .HasConversion(/* custom converter */);
    }
}
```

---

## ğŸ“¦ Project Dependencies

### Dependency Flow

```
Hartonomous.Core (no EF Core)
  â†“ (referenced by)
Hartonomous.Infrastructure (has EF Core)
  â†“ (referenced by)
Hartonomous.Data (generated entities)
  â†“ (references)
SQL Server 2025 Database (DACPAC deployed)
```

### Package Requirements

**Hartonomous.Core**:
- âŒ No EF Core dependencies
- âœ… System.Linq.Expressions (for specifications)

**Hartonomous.Infrastructure**:
- âœ… Microsoft.EntityFrameworkCore (10.0.0-rc.2.25502.107)
- âœ… Microsoft.EntityFrameworkCore.SqlServer

**Hartonomous.Data**:
- âœ… Microsoft.EntityFrameworkCore.SqlServer
- âœ… Microsoft.EntityFrameworkCore.Design (for scaffolding)

---

## ğŸš€ Usage Examples

### 1. Simple CRUD with Repository

```csharp
public class ModelService
{
    private readonly IRepository<Model, long> _modelRepo;
    private readonly IUnitOfWork _unitOfWork;

    public ModelService(IUnitOfWork unitOfWork)
    {
        _unitOfWork = unitOfWork;
        _modelRepo = unitOfWork.Repository<Model, long>();
    }

    public async Task<Model> CreateModelAsync(string name, string architecture)
    {
        var model = new Model
        {
            Name = name,
            Architecture = architecture,
            CreatedAt = DateTime.UtcNow,
            CreatedBy = "system"
        };

        await _modelRepo.AddAsync(model);
        await _unitOfWork.SaveChangesAsync();

        return model;
    }

    public async Task<IReadOnlyList<Model>> GetActiveModelsAsync()
    {
        return await _modelRepo.FindAsync(m => !m.IsDeleted);
    }
}
```

### 2. Complex Queries with Specifications

```csharp
public class RecentAtomsByModelSpecification : Specification<Atom>
{
    public RecentAtomsByModelSpecification(long modelId, int days = 7)
    {
        var cutoff = DateTime.UtcNow.AddDays(-days);
        
        AddCriteria(a => a.ModelId == modelId && a.CreatedAt >= cutoff);
        AddInclude(a => a.Model);
        AddInclude(a => a.AtomEmbeddings);
        AddOrderByDescending(a => a.CreatedAt);
        ApplyNoTracking();
    }
}

// Usage
var spec = new RecentAtomsByModelSpecification(modelId: 42, days: 30);
var recentAtoms = await atomRepo.FindAsync(spec);
```

### 3. Transactional Operations

```csharp
public async Task DistillModelAsync(long teacherModelId, long studentModelId)
{
    await _unitOfWork.ExecuteInTransactionAsync(async () =>
    {
        var modelRepo = _unitOfWork.Repository<Model, long>();
        var layerRepo = _unitOfWork.Repository<ModelLayer, long>();
        var atomRepo = _unitOfWork.Repository<Atom, long>();

        // 1. Fetch teacher model with layers
        var teacher = await modelRepo.GetByIdAsync(teacherModelId);
        var teacherLayers = await layerRepo.FindAsync(l => l.ModelId == teacherModelId);

        // 2. Create student model structure
        var student = await modelRepo.GetByIdAsync(studentModelId);
        // ... complex distillation logic

        // 3. Generate atoms from distilled weights
        var atoms = /* ... */;
        await atomRepo.AddRangeAsync(atoms);

        // Single atomic commit across all repositories
    });
}
```

---

## ğŸ› ï¸ Extending the Architecture

### Adding a New Repository

**Option 1: Use Generic Repository**
```csharp
var customRepo = unitOfWork.Repository<YourEntity, int>();
```

**Option 2: Create Specialized Repository**
```csharp
// Interface (Hartonomous.Core/Data/ICustomRepository.cs)
public interface ICustomRepository : IRepository<YourEntity, int>
{
    Task<YourEntity?> GetByUniqueFieldAsync(string field);
}

// Implementation (Hartonomous.Infrastructure/Data/CustomRepository.cs)
public class CustomRepository : EfRepository<YourEntity, int>, ICustomRepository
{
    public CustomRepository(DbContext context) : base(context) { }

    public async Task<YourEntity?> GetByUniqueFieldAsync(string field)
    {
        return await DbSet.FirstOrDefaultAsync(e => e.UniqueField == field);
    }
}
```

### Adding Custom Entity Logic

**Use partial classes**:
```csharp
// Hartonomous.Data/Entities/Model.Partial.cs
public partial class Model
{
    // Computed properties
    public bool IsActive => !IsDeleted && LastAccessedAt > DateTime.UtcNow.AddDays(-30);

    // Business logic methods
    public void MarkAsAccessed()
    {
        LastAccessedAt = DateTime.UtcNow;
    }

    // Validation
    public bool IsValid() => !string.IsNullOrWhiteSpace(Name) && ParameterCount > 0;
}
```

---

## ğŸ“‹ Best Practices

### âœ… DO

- âœ… Use `IUnitOfWork.ExecuteInTransactionAsync` for multi-step operations
- âœ… Create specifications for complex queries
- âœ… Add custom logic to partial classes (`*.Partial.cs`)
- âœ… Use `AsNoTracking()` for read-only queries
- âœ… Implement `IEntity<TKey>` on scaffolded entities (via partial classes)
- âœ… Run `generate-entities.ps1 -Force` after schema changes

### âŒ DON'T

- âŒ Edit generated entity files directly (use partial classes)
- âŒ Reference EF Core types in `Hartonomous.Core`
- âŒ Manually write SQL queries (use LINQ/specifications)
- âŒ Call `SaveChangesAsync` outside of `UnitOfWork`
- âŒ Create `DbContext` instances directly (use `IDbContextFactory`)
- âŒ Skip entity regeneration after DACPAC deployment

---

## ğŸ§ª Testing Strategy

### Unit Testing Repositories
```csharp
[Fact]
public async Task GetByIdAsync_ReturnsEntity_WhenExists()
{
    // Arrange
    var options = new DbContextOptionsBuilder<HartonomousDbContext>()
        .UseInMemoryDatabase(databaseName: "TestDb")
        .Options;

    await using var context = new HartonomousDbContext(options);
    var repository = new EfRepository<Model, long>(context);

    var model = new Model { Id = 1, Name = "Test Model" };
    await repository.AddAsync(model);
    await context.SaveChangesAsync();

    // Act
    var result = await repository.GetByIdAsync(1);

    // Assert
    Assert.NotNull(result);
    Assert.Equal("Test Model", result.Name);
}
```

### Testing Specifications
```csharp
[Fact]
public void ActiveModelsSpecification_FiltersDeletedModels()
{
    // Arrange
    var spec = new ActiveModelsSpecification("gpt", pageSize: 10, pageNumber: 0);

    // Assert
    Assert.NotNull(spec.Criteria);
    Assert.True(spec.AsNoTracking);
    Assert.Equal(10, spec.Take);
}
```

---

## ğŸ” Troubleshooting

### Issue: 100+ Build Errors After Scaffolding

**Cause**: Hartonomous.Core references entity types before scaffolding completes.

**Solution**:
1. Run `.\scripts\generate-entities.ps1 -Force`
2. Verify `Hartonomous.Data/Entities/` is populated
3. Add partial classes implementing `IEntity<TKey>` interfaces
4. Rebuild solution: `dotnet build`

### Issue: Scaffolding Fails with "Build Failed"

**Cause**: Circular dependency between Hartonomous.Core and Hartonomous.Data.

**Solution**:
- Temporarily comment out `<ProjectReference>` to Hartonomous.Data in Hartonomous.Core
- Run scaffolding
- Uncomment project reference
- Rebuild

### Issue: DbContext Missing OnModelCreatingPartial

**Cause**: Older scaffolding version or missing partial class.

**Solution**:
Create `HartonomousDbContext.Partial.cs` manually:
```csharp
public partial class HartonomousDbContext
{
    partial void OnModelCreatingPartial(ModelBuilder modelBuilder)
    {
        // Custom configurations
    }
}
```

---

## ğŸ“š Further Reading

- [EF Core Scaffolding Documentation](https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/)
- [Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)
- [Specification Pattern](https://martinfowler.com/apsupp/spec.pdf)
- [Unit of Work Pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

---

**Maintainer**: Hartonomous Development Team  
**Last Updated**: November 13, 2025  
**Architecture Version**: 2.0 (Database-First with Automated Scaffolding)
